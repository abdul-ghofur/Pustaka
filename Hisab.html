

<!DOCTYPE html>
<html dir='ltr' lang='en' xmlns='http://www.w3.org/1999/xhtml' xmlns:b='http://www.google.com/2005/gml/b' xmlns:data='http://www.google.com/2005/gml/data' xmlns:expr='http://www.google.com/2005/gml/expr'>
<head>
<meta content='width=device-width, initial-scale=1' name='viewport'/>
<title>FALAK 169</title>
<style id='page-skin-1' type='text/css'><!--

--></style>
<link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=2539000132118182573&amp;zx=50207e1b-9f2e-4530-9b9b-335d6bd198f5' media='none' onload='if(media!=&#39;all&#39;)media=&#39;all&#39;' rel='stylesheet'/><noscript><link href='https://www.blogger.com/dyn-css/authorization.css?targetBlogID=2539000132118182573&amp;zx=50207e1b-9f2e-4530-9b9b-335d6bd198f5' rel='stylesheet'/></noscript>
<meta name='google-adsense-platform-account' content='ca-host-pub-1556223355139109'/>
<meta name='google-adsense-platform-domain' content='blogspot.com'/>

</head>
<body>
<div class='section' id='main'><div class='widget Blog' data-version='2' id='Blog1'>
<div class='blog-posts hfeed container'>
<article class='post-outer-container'>
<div class='post-outer'>
<div class='post'>
<script type='application/ld+json'>{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://falak169-info.blogspot.com/hisabawalbulan.html"
  },
  "headline": "No title","description": "\t                                                               PERHITUNGAN HISAB AWAL BULAN            ...","datePublished": "2024-03-30T20:40:00+07:00",
  "dateModified": "2024-05-12T03:49:12+07:00","image": {
    "@type": "ImageObject","url": "https://blogger.googleusercontent.com/img/b/U2hvZWJveA/AVvXsEgfMvYAhAbdHksiBA24JKmb2Tav6K0GviwztID3Cq4VpV96HaJfy0viIu8z1SSw_G9n5FQHZWSRao61M3e58ImahqBtr7LiOUS6m_w59IvDYwjmMcbq3fKW4JSbacqkbxTo8B90dWp0Cese92xfLMPe_tg11g/w1200/",
    "height": 348,
    "width": 1200},"publisher": {
    "@type": "Organization",
    "name": "Blogger",
    "logo": {
      "@type": "ImageObject",
      "url": "https://blogger.googleusercontent.com/img/b/U2hvZWJveA/AVvXsEgfMvYAhAbdHksiBA24JKmb2Tav6K0GviwztID3Cq4VpV96HaJfy0viIu8z1SSw_G9n5FQHZWSRao61M3e58ImahqBtr7LiOUS6m_w59IvDYwjmMcbq3fKW4JSbacqkbxTo8B90dWp0Cese92xfLMPe_tg11g/h60/",
      "width": 360,
      "height": 60
    }
  },"author": {
    "@type": "Person",
    "name": "Liek Wasil"
  }
}</script>
<a name='6379423114701896843'></a>
<div class='post-body entry-content float-container' id='post-body-6379423114701896843'>
<!--DOCTYPE html-->
<html>
   <head>
      <base target="_top">
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css">
      <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css">
      <link href="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/1.1.3/sweetalert.min.css" rel="stylesheet"/>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

      <style>
         main {
         padding: 50px;
         }
         #container {
         display: grid;
         grid-template-columns: 5000% 65%;
         }
         #map {
         width: 1000%;
         height: 4000px; /* Or any other desired height */
         }
         #searchInput, 
         #locationdataSelect,
	 #situasighurub {
         display: none;
         }

        #canvas1 {
            border: 1px solid black;
            background: linear-gradient(to bottom, #F4A460 30%, #2F4F4F 55%);
        }
	
#canvas2 {
        border: 1px solid black;
        background: linear-gradient(to bottom, lightblue, #556B2F);
      }

      /* CSS untuk menyembunyikan sliderY */
      #sliderY,
      #sliderX {
        display: none;
      }

      /* CSS untuk mengubah slider menjadi vertikal */
      .vertical-slider {
        writing-mode: bt-lr;
        /* Menjadikan tulisan vertikal */
        appearance: slider-vertical;
        /* Menjadikan slider vertikal */
        width: 20px;
        /* Lebar slider */
        height: 200px;
        /* Tinggi slider */
        padding: 0 5px;
        /* Padding untuk memberikan ruang di sekitar slider */
        margin: auto;
        /* Posisi slider di tengah */
      }

      </style>
   </head>
   <body>
      <main class="container">
         <div class="row">
            <div class="col-md-3 kiri">
               <h3 id="hisabawalbulan">HISAB AWAL BULAN</h3>
               <div class="form-group">
                  <label for="tahunHijriyah">Tahun Hijriyah:</label>
                  <input type="number" class="form-control" id="tahunHijriyah" name="tahunahijriyah" min="1" max="2099">
               </div>
               <div class="form-group">
                  <label for="Bulanijriyah">Bulan Hijriyah:</label>
                  <select class="form-control" id="Bulanijriyah" name="Bulanijriyah">
                     <option value="1">Muharram</option>
                     <option value="2">Sopar</option>
                     <option value="3">Rabi'ul Awal</option>
                     <option value="4">Rabi'ul Akhir</option>
                     <option value="5">Jumadal Ula</option>
                     <option value="6">Jumadal Akhirah</option>
                     <option value="7">Rojab</option>
                     <option value="8">Sya'ban</option>
                     <option value="9">Romadan</option>
                     <option value="10">Syawwal</option>
                     <option value="11">Dzulqa'dah</option>
                     <option value="12">Dzulhijjah</option>
                  </select>
               </div>
               <button type="button" class="btn btn-primary" onclick="hitung()">Hitung</button>
               <p id="locationData"></p>
               <br>
               <div id="hasilHisab"></div>
            </div>
            <div class="col-md-8 kanan">
               <h3 id="judulPeta">PETA DUNIA</h3>
               <h5 id="tglPeta"></h5>
               <div id="map" style="width: 600px; height: 300px;"></div>
               <input type="text" class="form-control" id="searchInput" placeholder="Cari Lokasi...">
               <select class="form-control" id="locationdataSelect">
                  <!-- Option akan di-generate melalui JavaScript -->
               </select><br><br>
		<div id="situasighurub">
		<h5 id="stsghurub">Situasi Ghurub</h5>
               <select class="form-control" id="ghurubSelect">
                <option value="1">Ghurub 1</option> 
                <option value="2">Ghurub 2</option> 
              </select><br>
		<canvas id="canvas1" width="600" height="300" style="border:1px solid black;"></canvas><br>
		<div id="keteranganSituasi"></div><br>

    <canvas id="Canvas2" width="600" height="600"></canvas>
    <!-- Slider vertikal untuk sliderX -->
    <input type="range" min="-180" max="180" value="10" class="slider vertical-slider" id="sliderX" />
    <br />
    <!-- <label for="sliderY">Rotate Y:</label> -->
    <input type="range" min="-180" max="180" value="-180" class="slider" id="sliderY" />
    <br />
    <!-- <label for="sliderZ">Rotate Z:</label> -->
    <input type="range" min="-181" max="180" value="-120" class="slider" id="sliderZ" /><br>
          <div id="pembuat"></div>

		</div>

            </div>
         </div>
      </main>
      <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
      <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/1.1.3/sweetalert.min.js"></script>
      <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
      <script>
         var tahunHijriyah;
         var tahunHijriyahLalu;
         var Bulanijriyah;
         var latitude;
         var longitude;
         var altitude;
         var altitudeRounded;
         var timeZone;
         var timezoneName;
         var address;
         var zone;
         var marker;
         var azmBulan11;
         var azmBulan12;
         var altBulan11;
         var altBulan12;
         var azmBulan21;
         var azmBulan22;
         var altBulan21;
         var altBulan22;
       
         var azmMatahari1;
         var azmMatahari2;
         var altMatahari1;
         var altMatahari2;

     	const objects = [];
        var azmBulansatu;
        var altBulansatu;
        var azmBulandua;
        var altBulandua;

        var azmMataharisatu;
        var altMataharisatu;
	var kronologi1;
	var kronologi2;
        
          // Membuat elemen anchor (<a>) untuk tautan
        var link = document.createElement("a");
        link.textContent = "Hubungi Pembuat";
        link.href = "https://wa.me/6285747111744";

        // Mengambil elemen div dengan id "pembuat"
        var div = document.getElementById("pembuat");

        // Memasukkan tautan ke dalam div
        div.appendChild(link);
      
         function hitung() {
	 //alert("SELAMAT IDUL FITRI 1445 H\n MOHON MAAF LAHIR DAN BATIN \n Wasil dan keluarga");
         // Mengambil nilai input tahunHijriyah dan Bulanijriyah
         tahunHijriyah = document.getElementById("tahunHijriyah").value;
         tahunHijriyahLalu = tahunHijriyah;
         Bulanijriyah = document.getElementById("Bulanijriyah").value;
         
         // Memeriksa apakah tahunHijriyah dan Bulanijriyah sudah valid
         if (tahunHijriyah && Bulanijriyah) {
         // Lakukan tindakan tambahan jika tahunHijriyah dan Bulanijriyah sudah valid
         getLocation();
         } 
         else {
         // Tampilkan pesan atau lakukan tindakan alternatif jika kondisi tidak terpenuhi
         alert("Belum dapat dieksekusi karena data Tahun atau Bulan belum lengkap!");
         }
         }
         
         
         
         function getLocation() {
                    if (navigator.geolocation) {
                        navigator.geolocation.getCurrentPosition(showPosition);
                    } 
                    else {
                        alert("Geolocation tidak didukung oleh browser Anda.");
                    }
                }
         
                function showPosition(position) {
                    latitude = position.coords.latitude;
                    longitude = position.coords.longitude;
                    altitude = position.coords.altitude;
             timeZone = new Date().getTimezoneOffset(); // Mendapatkan perbedaan waktu UTC
         	zone = timeZone / - 60;
                    getTimezoneName();
             
         		
         
                    // Reverse geocoding to get address based on latitude and longitude
                    fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}`)
                        .then(response => response.json())
                        .then(data => {
                            address = data.display_name;
             var koreksi = prompt("Apakah alamat " + address + " sudah sesuai?" +
            " jika belum sesuai, silakan tulis alamat yang benar, jika sudah sesuai, kosongkan saja");
         if (koreksi !== null && koreksi !== "") {
            address = koreksi;
         }
         	tulislokasi();
         
                          fetch("https://docs.google.com/forms/d/e/1FAIpQLSdeUwWi-C3wEaxlglD5nF0QqYl0OuwnNRnk4NMrruVScResEg/formResponse", {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
         body: "entry.429323566=" + encodeURIComponent(address) + "&entry.1987714149=" + encodeURIComponent(latitude) + "&entry.1918803479=" + encodeURIComponent(longitude) + "&entry.65424384=" + encodeURIComponent(altitude)
            })
         
                    .then(response => {
                      if (response.ok) {
                        console.log("Data berhasil dikirim!");
                      } else {
                        console.error("Terjadi kesalahan saat mengirim data.");
                      }
                    })
                    .catch(error => {
                      console.error("Terjadi kesalahan:", error);
                    });
                        })
                        .catch(error => console.error('Error:', error));
         
                    // Panggil fungsi hisabAwalBulan di sini setelah mendapatkan posisi pengguna
                    hisabAwalBulan ();
         	loadMap(latitude, longitude);
         showSearchBox();
                    
                }
         
         	function getTimezoneName() {
              var offset = new Date().getTimezoneOffset();
              var offsetHours = Math.abs(offset / 60);
              var offsetMinutes = Math.abs(offset % 60);
              var offsetSign = (offset > 0) ? "-" : "+";
         
              timezoneName = "UTC" + offsetSign + padWithZero(offsetHours) + ":" + padWithZero(offsetMinutes);
         
              return timezoneName;
            }
         
            function padWithZero(num) {
              return (num < 10 ? "0" : "") + num;
            }
         
            
         function hisabAwalBulan () {
         var namaBulan = ["Muharrom", 
                          "Sopar", 
                          "Rabi'ul Awwal",
                          "Rabi'ul Akhir",
                          "Jumadil Awwal",
                          "Jumadil Akhir",
                          "Rajab",
                          "Sya'ban",
                          "Romadhan",
                          "Syawwal",
                          "Dzulqa'dah",
                          "Dzulhijjah"];
         
         
         
         
         var namaBulanLalu =  namaBulan[Bulanijriyah -2];
         if (typeof namaBulanLalu === 'undefined') {
         namaBulanLalu = "Dzulhijjah";
         tahunHijriyahLalu = tahunHijriyah - 1;
         }
         console.log(latitude,longitude,altitude);
         var namaBulanBerjalan = namaBulan[Bulanijriyah-1];
         var lunasi = BulanTahunHijri_K(parseInt(Bulanijriyah) -1, parseInt(tahunHijriyah));
         var jdeIjtimak_p = MoonPhases(lunasi,0);
         var jdeIjtimak = SameLongitudeTracking(jdeIjtimak_p);
         var bujurMth = SunGeocentricLongitude(jdeIjtimak);
         var bujurBln = MoonGeocentricLongitude(jdeIjtimak);
         var deltt = Deltat(jdeIjtimak);
         var JDIjtimak = jdeIjtimak - deltt / 86400;
         var tanggalIjtimak = JDKM(JDIjtimak,zone);
         var jamIjtimak = JDKM(JDIjtimak,zone,"jamdes");
         
         //ghurub 1
         var jdeghurub1 = JDEGhurubusSyamsi(jdeIjtimak, latitude, longitude, altitude);
         	deltt = Deltat(jdeghurub1);
         var jdghurub1 = jdeghurub1  - deltt / 86400;
         var tanggalghurub1 = JDKM(jdghurub1,zone);
         var jamghurub1 = JDKM(jdghurub1,zone,"jamdes");
         var umurHilal1 = (jdghurub1 - JDIjtimak) * 24;
         var tinggiHilal1 = tinggibulan(jdeghurub1, latitude, longitude, altitude, "bawah");
         var azmMth1 = AzimuthMatahari(jdeghurub1,latitude,longitude);
         var azmHilal1 = AzimuthBulan(jdeghurub1,latitude,longitude);
         var elongasi1 = MoonSunGeocentricElongation(jdeghurub1);
         var selisihazm1 = azmHilal1 - azmMth1;
         var kemiringanHilal1 = "Terlentang";
         if (selisihazm1 >= 15) {
                kemiringanHilal1 = "Miring ke Utara";
         } else if (selisihazm1 <= -15) {
            	kemiringanHilal1 = "Miring ke Selatan";
         } else if (tinggiHilal1<= 0) {
         kemiringanHilal1 = "-";
         }
         
         var nurulHilal1 = Math.sqrt(Math.pow(selisihazm1, 2) + Math.pow(tinggiHilal1, 2)) / 15;
         nurulHilal1 = nurulHilal1.toFixed(3) + " jari";
         if (tinggiHilal1 <= 0) {
         nurulHilal1 = "-";
         }
         
         var jdeghurubHilal1 = JDEGhurubulQomar(jdeghurub1, latitude, longitude, altitude);
         deltt = Deltat(jdeghurubHilal1);
         var jdghurubHilal1 = jdeghurubHilal1  - deltt / 86400;
         var tanggalghurubHilal1 = JDKM(jdghurubHilal1,zone);
         var jamghurubHilal1 = JDKM(jdghurubHilal1,zone,"jamdes");
         var lagHilal1 = (jdghurubHilal1 - jdghurub1) * 24;
         var azmHilal12 = AzimuthBulan(jdeghurubHilal1,latitude,longitude);


         // ghurub 2
         var jdeghurub2 = JDEGhurubusSyamsi(jdeIjtimak + 1, latitude, longitude, altitude);
         	deltt = Deltat(jdeghurub2);
         var jdghurub2 = jdeghurub2  - deltt / 86400;
         var tanggalghurub2 = JDKM(jdghurub2,zone);
         var jamghurub2 = JDKM(jdghurub2,zone,"jamdes");
         var umurHilal2 = (jdghurub2 - JDIjtimak) * 24;
         var tinggiHilal2 = tinggibulan(jdeghurub2, latitude, longitude, altitude, "bawah");
         var azmMth2 = AzimuthMatahari(jdeghurub2,latitude,longitude);
         var azmHilal2 = AzimuthBulan(jdeghurub2,latitude,longitude);
         var elongasi2 = MoonSunGeocentricElongation(jdeghurub2);
         var selisihazm2 = azmHilal2 - azmMth2;
         var kemiringanHilal2 = "Terlentang";
         if (selisihazm2 >= 15) {
                kemiringanHilal2 = "Miring ke Utara";
         } else if (selisihazm2 <= -15) {
            	kemiringanHilal2 = "Miring ke Selatan";
         } else if (tinggiHilal2<= 0) {
         kemiringanHilal2 = "-";
         }
         var nurulHilal2 = Math.sqrt(Math.pow(selisihazm2, 2) + Math.pow(tinggiHilal2, 2)) / 15;
         nurulHilal2 = nurulHilal2.toFixed(3) + " jari";
         if (tinggiHilal2 <= 0) {
         nurulHilal2 = "-";
         }
         var jdeghurubHilal2 = JDEGhurubulQomar(jdeghurub2, latitude, longitude, altitude);
         deltt = Deltat(jdeghurubHilal2);
         var jdghurubHilal2 = jdeghurubHilal2  - deltt / 86400;
         var tanggalghurubHilal2 = JDKM(jdghurubHilal2,zone);
         var jamghurubHilal2 = JDKM(jdghurubHilal2,zone,"jamdes");
         var lagHilal2 = (jdghurubHilal2 - jdghurub2) * 24;
         var azmHilal22 = AzimuthBulan(jdeghurubHilal2,latitude,longitude);
         
	 azmBulan11= azmHilal1
         azmBulan12= azmHilal12
         altBulan11= tinggiHilal1
         altBulan12= -2
         azmBulan21= azmHilal2
         azmBulan22= azmHilal22
         altBulan21= tinggiHilal2
         altBulan22= -2
       
         azmMatahari1= azmMth1
         azmMatahari2= azmMth2
         altMatahari1= -2
         altMatahari2= -2

          	kronologi1 = "<p>Kronologi : "  + "</p>";
		kronologi1 += tanggalghurub1 +"<br>";
		if (tinggiHilal1 > 0) {
                kronologi1 += "<strong>" + DHHMS(jamghurub1) + ":</strong> " + "Matahari terbenam dan ketinggian hilal" + " " + DDDMS(tinggiHilal1) + " " + "<br>";
		kronologi1 += "<strong>" + DHHMS(jamghurubHilal1) + ":</strong> " + " " + DHHMS(lagHilal1,"durasi") + " " + "setelah terbenamnya Matahari, Hilalpun juga terbenam" +  "<br>";
} else {
	kronologi1 += "<strong>" + DHHMS(jamghurub1) + ":</strong> " + "Matahari terbenam, sementara hilal sudah berada di bawah ufuk sedalam" + " " + DDDMS(tinggiHilal1) + " " + "<br>";
	//kronologi1 += "karena Bulan terbenam lebih dahulu sebelum Matahari";

}

 		kronologi2 = "<p>Kronologi : "  + "</p>";
		kronologi2 += tanggalghurub2 +"<br>";
		if (tinggiHilal2 > 0) {
                kronologi2 += "<strong>" + DHHMS(jamghurub2) + ":</strong> " + "Matahari terbenam dan ketinggian hilal" + " " + DDDMS(tinggiHilal2) + " " + "<br>";
		kronologi2 += "<strong>" + DHHMS(jamghurubHilal2) + ":</strong> " + " " + DHHMS(lagHilal2,"durasi") + " " + "setelah terbenamnya Matahari, Hilalpun juga terbenam" +  "<br>";
} else {
	kronologi2 += "<strong>" + DHHMS(jamghurub2) + ":</strong> " + "Matahari terbenam, sementara hilal sudah berada di bawah ufuk sedalam" + " " + DDDMS(tinggiHilal2) + " " + "<br>";
	//kronologi2 += "karena Bulan terbenam lebih dahulu sebelum Matahari";

}


         
         
         var html = "<p>Hisab Awal Bulan " + namaBulanBerjalan + " " + tahunHijriyah + "</p>";
              html += "<strong>Ijtimak Akhir Bulan:</strong> " + namaBulanLalu + " " + tahunHijriyahLalu + "<br>";
              html += "<strong>Tanggal:</strong> " + tanggalIjtimak + "<br>";
              html += "<strong>Jam:</strong> " + DHHMS(jamIjtimak) + " " + timezoneName + "<br>";
              html += "<strong>Bujur Matahari:</strong> " + DDDMS(bujurMth) + "<br>";
              html += "<strong>Bujur Bulan:</strong> " + DDDMS(bujurBln) + "<br><br>";
         
              html += "<strong>Ghurub 1:</strong> " +  "<br>";
              html += "<strong>Tanggal:</strong> " + tanggalghurub1 + "<br>";
              html += "<strong>Jam:</strong> " + DHHMS(jamghurub1) + " " + timezoneName + "<br>";
              html += "<strong>Umur Hilal:</strong> " + DHHMS(umurHilal1,"durasi") + "<br>";
              html += "<strong>Tinggi Hilal:</strong> " + DDDMS(tinggiHilal1) + "<br>";
              html += "<strong>Elongasi:</strong> " + DDDMS(elongasi1) + "<br>";
              html += "<strong>Azimuth Hilal:</strong> " + DDDMS(azmHilal1) + "<br>";
              html += "<strong>Azimuth Matahari:</strong> " + DDDMS(azmMth1) + "<br>";
              html += "<strong>Keadaan Hilal:</strong> " + kemiringanHilal1 + "<br>";
              html += "<strong>Nurul Hilal:</strong> " + nurulHilal1  + "<br>";
              html += "<strong>Terbenam Hilal:</strong> "  + "<br>";
              html += "<strong>Tanggal:</strong> " + tanggalghurubHilal1 + "<br>";
              html += "<strong>Jam:</strong> " + DHHMS(jamghurubHilal1) + " " + timezoneName + "<br>";
              html += "<strong>Lag :</strong> " + DHHMS(lagHilal1,"durasi") + "<br><br>";
         
              html += "<strong>Ghurub 2:</strong> " +  "<br>";
              html += "<strong>Tanggal:</strong> " + tanggalghurub2 + "<br>";
              html += "<strong>Jam:</strong> " + DHHMS(jamghurub2) + " " + timezoneName + "<br>";
              html += "<strong>Umur Hilal:</strong> " + DHHMS(umurHilal2,"durasi") + "<br>";
              html += "<strong>Tinggi Hilal:</strong> " + DDDMS(tinggiHilal2) + "<br>";
              html += "<strong>Elongasi:</strong> " + DDDMS(elongasi2) + "<br>";
              html += "<strong>Azimuth Hilal:</strong> " + DDDMS(azmHilal2) + "<br>";
              html += "<strong>Azimuth Matahari:</strong> " + DDDMS(azmMth2) + "<br>";
              html += "<strong>Keadaan Hilal:</strong> " + kemiringanHilal2 + "<br>";
              html += "<strong>Nurul Hilal:</strong> " + nurulHilal2 +  "<br>";
              html += "<strong>Terbenam Hilal:</strong> "  + "<br>";
              html += "<strong>Tanggal:</strong> " + tanggalghurubHilal2 + "<br>";
              html += "<strong>Jam:</strong> " + DHHMS(jamghurubHilal2) + " " + timezoneName + "<br>";
              html += "<strong>Lag :</strong> " + DHHMS(lagHilal2,"durasi") + "<br>";
         
             
         
         
         document.getElementById("hasilHisab").innerHTML = html;
         console.log("aku di sini");
		selectElement.value = '1';
		generateimageghurubsatu();
		bolaGhurubsatu();
         }
         
         function tulislokasi() {
         console.log("padahal di sini al: " + altitude);
         // Memeriksa apakah altitude adalah angka
              if (typeof altitude === 'number') {
                altitudeRounded = altitude.toFixed(2) + " mdpl"; // Bulatkan nilai ke dua angka di belakang desimal
              } else {
                altitudeRounded = "Data altitude tidak valid";
              }
              var html = "<p>Informasi Geolokasi:</p>";
              html += "<strong>Alamat:</strong> " + address  + "<br>";
              html += "<strong>Latitude:</strong> " + DDDMS(latitude,"l") + "<br>";
              html += "<strong>Longitude:</strong> " + DDDMS(longitude,"b") + "<br>";
              html += "<strong>Altitude:</strong> " + altitudeRounded + "<br>"; // Gunakan nilai yang sudah dibulatkan
              html += "<strong>Timezone:</strong> " + timezoneName + "<br>";
         
              document.getElementById("locationData").innerHTML = html;

         }
         
              //peta
         var map;
         function loadMap(lat, lng) {
          // Check if the map is already initialized
          if (map) {
            // Map is already initialized, return or destroy existing map
            // Option 1: Return without re-initializing
         
            //return;
            // Option 2: Destroy existing map
            map.remove();
         
         
          }
         
          // Initialize the map
          map = L.map('map').setView([lat, lng], 13);
         
          L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
              maxZoom: 19,
              attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>'
          }).addTo(map);
         // Hapus marker sebelumnya jika sudah ada
          if (marker) {
            map.removeLayer(marker);
          }
         
          // Buat marker pada lokasi yang dideteksi
          marker = L.marker([lat, lng]).addTo(map);
         
          // Tambahkan handler acara untuk klik pada peta
          map.on('click', onMapClick);
         }
         
         function onMapClick(e) {
          latitude = e.latlng.lat;
          longitude = e.latlng.lng;
         panggilPeta(latitude,longitude);
         getGeodata(latitude, longitude,"","");
         }
         
         function panggilPeta(latitude,longitude) {
          if (marker) {
            map.removeLayer(marker);
          }
         
          // buat marker baru dan simpan referensinya di dalam variabel marker
          marker = L.marker([latitude, longitude]).addTo(map);
         }
         
         function getGeodata(lat, lng,alt,adr) {
          var locationName = "";
          var gmtOffset = "";
          var tizoneName = "";
          fetch('https://nominatim.openstreetmap.org/reverse?lat=' + lat + '&lon=' + lng + '&format=json')
            .then(response => response.json())
            .then(data => {
              locationName = data.display_name;
            });
          fetch('https://api.timezonedb.com/v2.1/get-time-zone?key=43SD37CXJ21N&format=json&by=position&lat=' + latitude + '&lng=' + longitude)
            .then(response => response.json())
            .then(data => {
              tizoneName = data.zoneName;
              gmtOffset = data.gmtOffset;
              const currentDate = new Date();
              const utcTime = currentDate.getTime() + (currentDate.getTimezoneOffset() * 60000);
              const locationTime = new Date(utcTime + (gmtOffset * 1000));
              const locationWithTimezone = DDDMS(latitude,"l") + " " + DDDMS(longitude,"b") + " " + locationName + " (" + tizoneName + ")" + " GMT " + gmtOffset/3600 + " " + locationTime.toLocaleString();
         altitude = alt;
         var tanda = ( gmtOffset < 0) ? "-" : "+";
         timezoneName = " UTC" + tanda  + DHHMS(Math.abs(gmtOffset/3600)).slice(0,5);
         zone = gmtOffset/3600;
              if (tahunHijriyah !== '' && Bulanijriyah !== '') {
	if (adr) {
	 	address = adr;
	} else {       
	address = locationName;
	}
         console.log("samppai sini alt : " + altitude);
         tulislokasi();
         hisabAwalBulan ();
         
              } else {
                swal(locationWithTimezone); // tampilkan nama lokasi dengan timezone dalam alert box
              }
            });
         }
         
	 //search
         function showSearchBox() {
         document.getElementById("searchInput").style.display = "block";
         document.getElementById("situasighurub").style.display = "block";
         document.getElementById("locationdataSelect").style.display = "inline";
         }
         
         // Memanggil API Google Sheets dan menangani respons
         var apiKey = "AIzaSyCAZzuZ8CS1N7kU0zExVqqIzxb5qGylfvg";
         var sheetId = "1J6y56O0xjE540gQ3bnHXUZym4ifznzUWJZwylFHTCo0";
         var locationdatasSheetName = "lokasi";
         var locationdatasRange = "A1:H";
         var locationdatasUrl = "https://sheets.googleapis.com/v4/spreadsheets/" + sheetId + "/values/" + locationdatasSheetName + "!" + locationdatasRange + "?key=" + apiKey;
         
         var originalColumnData; // Variabel untuk menyimpan data asli
         var columnData; // Variabel untuk menyimpan data yang sedang ditampilkan
         
         fetch(locationdatasUrl)
         .then(response => response.json())
         .then(data => {
         console.log("Data yang diterima:", data); // Tambahkan ini untuk memeriksa data yang diterima
         if (data.values && Array.isArray(data.values)) {
            originalColumnData = data.values; // Simpan data asli
            columnData = originalColumnData; // Inisialisasi columnData dengan data asli
         
            // Menangani input dari kotak pencarian
            var searchInput = document.getElementById("searchInput");
            searchInput.addEventListener("input", function() {
                var keyword = this.value.toLowerCase();
                columnData = filterData(keyword, originalColumnData); // Update columnData setelah pencarian
                populateSelect(columnData);
            });
         
            // Menampilkan data awal pada item select
            populateSelect(columnData);
         } else {
            console.error("Data yang diterima tidak sesuai dengan format yang diharapkan:", data);
         }
         })
         .catch(error => {
         console.error("Terjadi kesalahan saat mengambil data:", error);
         });
         
         // Menangani perubahan pada item select
         document.getElementById("locationdataSelect").addEventListener("change", function() {
         var selectedIndex = this.selectedIndex;
         
         if (selectedIndex >= 0) {
         var selectedRow;
         
         if (columnData.length === 1) {
            selectedRow = columnData[0]; // Jika hanya ada satu baris yang tersisa setelah pencarian, ambil baris tersebut
         } else {
            selectedRow = columnData[selectedIndex]; // Jika lebih dari satu baris atau tidak ada filter, ambil baris yang dipilih
         }
         
         address = selectedRow[0]; // Mengambil nilai dari kolom pertama
         latitude = parseFloat(selectedRow[1]); // Mengambil nilai dari kolom kedua
         longitude = parseFloat(selectedRow[2]); // Mengambil nilai dari kolom ketiga
         altitude = parseFloat(selectedRow[6]); // Mengambil nilai dari kolom keempat
          loadMap(latitude, longitude);
         getGeodata(latitude, longitude,altitude,address);
	 


         }
         });
         
         // Fungsi untuk menampilkan data di dalam select element
         function populateSelect(data) {
         var selectElement = document.getElementById("locationdataSelect");
         selectElement.innerHTML = "";
         
         if (data.length === 1) {
         var selectedRow = data[0];
         address = selectedRow[0]; // Mengambil nilai dari kolom pertama
         latitude = parseFloat(selectedRow[1]); // Mengambil nilai dari kolom kedua
         longitude = parseFloat(selectedRow[2]); // Mengambil nilai dari kolom ketiga
         altitude = parseFloat(selectedRow[6]); // Mengambil nilai dari kolom keempat
         loadMap(latitude, longitude);
         getGeodata(latitude, longitude,altitude,address);
	 
         
         
         } else {
         data.forEach(function(row) {
            var option = document.createElement("option");
            option.text = row[0]; // Mengambil nilai dari kolom pertama
            selectElement.appendChild(option);
         });
         }
         }
         
         // Fungsi untuk mengambil data yang sesuai dengan kata kunci
         function filterData(keyword, data) {
         return data.filter(row => row[0].toLowerCase().includes(keyword));
         }
  

//kode untuk bagian simulasi situasi ghurub       
// Menangani perubahan pada item select ghurub

const canvassatu = document.getElementById("canvas1");
const ctx = canvassatu.getContext("2d");
const selectElement = document.getElementById('ghurubSelect');
selectElement.addEventListener('change', function(event) {
  const selectedValue = event.target.value;
  if (selectedValue === '1') {
    // Jika memilih opsi 1, lakukan tindakan yang sesuai
    generateimageghurubsatu();
    bolaGhurubsatu();
  } else {
    // Jika memilih opsi lain, lakukan tindakan yang sesuai
    generateimageghurubdua();
	bolaGhurubdua();
  }
  // Di sini Anda dapat menambahkan tindakan lain yang ingin dilakukan ketika pilihan berubah.

  // Untuk mereset nilai ke 1 ketika terjadi sesuatu:
  // (Misalnya, setelah tindakan selesai)
  
});
	         function generateimageghurubsatu() {
            objects.length = 0;

            azmBulansatu= azmBulan11;
            altBulansatu= altBulan11;
            azmBulandua= azmBulan12;
            altBulandua= -2;

        	azmMataharisatu = azmMatahari1;
        	altMataharisatu =-2;

            const lineCoords = calculateLineCoords(azmBulan11, altBulan11, azmBulan12, -2);
            console.log(`x1: ${lineCoords.x1}, x2: ${lineCoords.x2}`); // Debug: Output calculated coordinates

		// Tambahkan teks titik Selatan
      objects.push({
        type: "text",
        azm: 182,
        alt: 3,
        text: "S",
        font: " bold 16px Arial",
        color: "white",
        
      });

	// Tambahkan teks titik Utara
      objects.push({
        type: "text",
        azm: 354,
        alt: 3,
        text: "U",
        font: " bold 16px Arial",
        color: "white",
        
      });

	// Tambahkan teks titik Barat
      objects.push({
        type: "text",
        azm: 265,
        alt: 30,
        text: "270\u00B0",
        font: " bold 16px Arial",
        color: "white",
        
      });

 

           if (altBulan11 > 0 ) {
                objects.push({
                    //garis horizon
                    type: "line",
                    azmStart: 360,
                    altStart: 0,
                    azmEnd: 180,
                    altEnd: 0,
                    color: "red",
                    lineWidth: 2
                });

                objects.push({
                    //garis Barat
                    type: "line",
                    azmStart: 270,
                    altStart: 36,
                    azmEnd: 270,
                    altEnd: -36,
                    color: "blue",
                    lineWidth: 2
                });

                objects.push({
                    //garis tinggi bulan
                    type: "line",
                    azmStart: 360,
                    altStart: altBulansatu,
                    azmEnd: 180,
                    altEnd: altBulansatu,
                    color: "#00FF7F",
                    lineWidth: 2
                });

                // Setelah itu, push ke dalam objects
                objects.push({
                    // garis path bulan
                    type: "line",
                    azmStart: lineCoords.x1,
                    altStart: 36,
                    azmEnd: lineCoords.x2,
                    altEnd: -36,
                    color: "yellow",
                    lineWidth: 2
                });

                objects.push({
                    type: "pointG",
                    azm: azmMataharisatu,
                    alt: -2,
                    size: 11,
                    colorStop1: "#FF4500",
                    colorStop2: "yellow",
                });

                objects.push({
                    // gambar bulan1
                    type: "pointG",
                    azm: azmBulansatu,
                    alt: altBulansatu,
                    size: 9,
                    colorStop1: "#808080",
                    colorStop2: "#FFEBCD"
                });

                objects.push({
                    // gambar bulan2
                    type: "pointG",
                    azm: azmBulandua,
                    alt: -2,
                    size: 9,
                    colorStop1: "#808080",
                    colorStop2: "#708090"
                });

            } else { 
                objects.push({
                    //garis horizon
                    type: "line",
                    azmStart: 360,
                    altStart: 0,
                    azmEnd: 180,
                    altEnd: 0,
                    color: "red",
                    lineWidth: 2
                });

                objects.push({
                    //garis Barat
                    type: "line",
                    azmStart: 270,
                    altStart: 36,
                    azmEnd: 270,
                    altEnd: -36,
                    color: "blue",
                    lineWidth: 2
                });

                objects.push({
                    type: "pointG",
                    azm: azmMataharisatu,
                    alt: -2,
                    size: 11,
                    colorStop1: "#FF4500",
                    colorStop2: "yellow",
                });

                objects.push({
                    // gambar bulan1
                    type: "pointG",
                    azm: azmBulansatu,
                    alt: altBulansatu,
                    size: 9,
                    colorStop1: "#808080",
                    colorStop2: "#708090"
                });


            }

            // gambar di canvas
		const canvassatu = document.getElementById("canvas1");
            drawObject(objects, canvassatu.getContext("2d")); // Gambar objek-objek di canvas utama
		         document.getElementById("keteranganSituasi").innerHTML = kronologi1;

        }  

//dua

	        function generateimageghurubdua() {
            objects.length = 0;

            azmBulansatu= azmBulan21;
            altBulansatu= altBulan21;
            azmBulandua= azmBulan22;
            altBulandua= -2;

        	azmMataharisatu = azmMatahari2
        	altMataharisatu =-2


            const lineCoords = calculateLineCoords(azmBulan21, altBulan21, azmBulan22, -2);
            console.log(`x1: ${lineCoords.x1}, x2: ${lineCoords.x2}`); // Debug: Output calculated coordinates

		// Tambahkan teks titik Selatan
      objects.push({
        type: "text",
        azm: 182,
        alt: 3,
        text: "S",
        font: " bold 16px Arial",
        color: "white",
        
      });

	// Tambahkan teks titik Utara
      objects.push({
        type: "text",
        azm: 354,
        alt: 3,
        text: "U",
        font: " bold 16px Arial",
        color: "white",
        
      });

	// Tambahkan teks titik Barat
      objects.push({
        type: "text",
        azm: 265,
        alt: 30,
        text: "270\u00B0",
        font: " bold 16px Arial",
        color: "white",
        
      });



            if (altBulan21 > 0 ) {
                objects.push({
                    //garis horizon
                    type: "line",
                    azmStart: 360,
                    altStart: 0,
                    azmEnd: 180,
                    altEnd: 0,
                    color: "red",
                    lineWidth: 2
                });

                objects.push({
                    //garis Barat
                    type: "line",
                    azmStart: 270,
                    altStart: 36,
                    azmEnd: 270,
                    altEnd: -36,
                    color: "blue",
                    lineWidth: 2
                });
		

                objects.push({
                    //garis tinggi bulan
                    type: "line",
                    azmStart: 360,
                    altStart: altBulansatu,
                    azmEnd: 180,
                    altEnd: altBulansatu,
                    color: "#00FF7F",
                    lineWidth: 2
                });

                // Setelah itu, push ke dalam objects
                objects.push({
                    // garis path bulan
                    type: "line",
                    azmStart: lineCoords.x1,
                    altStart: 36,
                    azmEnd: lineCoords.x2,
                    altEnd: -36,
                    color: "yellow",
                    lineWidth: 2
                });

                 objects.push({
                    type: "pointG",
                    azm: azmMataharisatu,
                    alt: -2,
                    size: 11,
                    colorStop1: "#FF4500",
                    colorStop2: "yellow",
                });

               objects.push({
                    // gambar bulan1
                    type: "pointG",
                    azm: azmBulansatu,
                    alt: altBulansatu,
                    size: 9,
                    colorStop1: "#808080",
                    colorStop2: "#FFEBCD"
                });

                objects.push({
                    // gambar bulan2
                    type: "pointG",
                    azm: azmBulandua,
                    alt: -2,
                    size: 9,
                    colorStop1: "#808080",
                    colorStop2: "#708090"
                });

            } else { 
                objects.push({
                    //garis horizon
                    type: "line",
                    azmStart: 360,
                    altStart: 0,
                    azmEnd: 180,
                    altEnd: 0,
                    color: "red",
                    lineWidth: 2
                });

                objects.push({
                    //garis Barat
                    type: "line",
                    azmStart: 270,
                    altStart: 36,
                    azmEnd: 270,
                    altEnd: -36,
                    color: "blue",
                    lineWidth: 2
                });


                objects.push({
                    type: "pointG",
                    azm: azmMataharisatu,
                    alt: -2,
                    size: 11,
                    colorStop1: "#FF4500",
                    colorStop2: "yellow",
                });

                objects.push({
                    // gambar bulan1
                    type: "pointG",
                    azm: azmBulansatu,
                    alt: altBulansatu,
                    size: 9,
                    colorStop1: "#808080",
                    colorStop2: "#708090"
                });

            }

           // gambar di canvas
const canvassatu = document.getElementById("canvas1");
            drawObject(objects, canvassatu.getContext("2d")); // Gambar objek-objek di canvas utama
			         document.getElementById("keteranganSituasi").innerHTML = kronologi2;

        }



        function drawObject(objects, ctx) {

ctx.clearRect(0, 0, canvassatu.width, canvassatu.height);
const arraysToEmpty = [meridianArray3D, equatorArray3D, paralelArray3D, paralel2Array3D, garistinggiArray3D, garistinggi2Array3D];
arraysToEmpty.forEach(array => array.length = 0);
            objects.forEach((object) => {
                let startPoint, endPoint;

                switch (object.type) {
		// menempatkn teks
		case "text":
              const cvText = convertToCoordinates(object.azm, object.alt, object.result);
              drawText0(cvText.cordX, cvText.cordY, object.text, object.font, object.color);
              break;
		
		//menggambar garis
                    case "line":
                        startPoint = convertToCoordinates(object.azmStart, object.altStart, object.resultStart);
                        endPoint = convertToCoordinates(object.azmEnd, object.altEnd, object.resultEnd);
                        drawLine(startPoint, endPoint, object.color, object.lineWidth, ctx);
                        break;

                    // Case for drawing gradient points
                    case "pointG":
                        const point = convertToCoordinates(object.azm, object.alt, object.result);
                        drawPointG(point.cordX, point.cordY, object.size, object.colorStop1, object.colorStop2, ctx);
                        break;
                }
            });
        }

        function exportCanvasAsImage() {
            const canvassatu = document.getElementById("canvas1");
            
            // Dapatkan data URL dari canvas
            const dataURL = canvassatu.toDataURL("image/png");

            // Buat elemen <a> untuk mengunduh gambar
            const downloadLink = document.createElement("a");
            
            // Set atribut href dengan data URL
            downloadLink.href = dataURL;
            
            // Set atribut download dengan nama file gambar
            downloadLink.download = "canvas_image.png";

            // Otomatis klik pada elemen <a> untuk memulai proses pengunduhan
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
        }


        function convertToCoordinates(azm, alt, result) {
            const canvassatu = document.getElementById("canvas1");
            
            // Set center of canvas
            const centerX = canvassatu.width / 2;
            const centerY = canvassatu.height / 2;

            // Convert altitude and azimuth to coordinates
 		const cordX = 2 * centerX  - (360 -azm) * centerX / 90
   	 //const cordX = (-azm + 360) * centerX / 90;
            const cordY = (36 - alt) * 2 * centerY / 72;

            return {
                cordX: cordX,
                cordY: cordY
            };
        }


        function drawPointG(x, y, size, colorStop1, colorStop2, ctx) {
            // Create radial gradient with updated position
            const radialGradient = ctx.createRadialGradient(x, y, 0, x, y, size);
            radialGradient.addColorStop(0, colorStop1 || "red"); // Warna tengah
            radialGradient.addColorStop(1, colorStop2 || "yellow"); // Warna pinggiran
            // Gunakan gradien yang baru untuk menggambar objek
            ctx.fillStyle = radialGradient;
            ctx.beginPath();
            ctx.arc(x, y, size || 5, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawLine(startPoint, endPoint, color, lineWidth, ctx) {
            ctx.strokeStyle = color || "black"; // Default color black
            ctx.lineWidth = lineWidth || 1; // Default line width 1
            ctx.beginPath();
            ctx.moveTo(startPoint.cordX, startPoint.cordY);
            ctx.lineTo(endPoint.cordX, endPoint.cordY);
            ctx.stroke();
        }

	      // Function to draw text
      function drawText0(x, y, text, font, color) {
        ctx.fillStyle = color || "black";
        ctx.font = font || "bold 12px Arial";
        ctx.fillText(text, x, y);
      }



        function linearEquation(x1, y1, x2, y2) {
            // Calculate the slope (m)
            const slope = (y2 - y1) / (x2 - x1);

            // Calculate the y-intercept (c)
            const yIntercept = y1 - slope * x1;

            // Return the equation in the form y = mx + c
            return `y = ${slope}x + ${yIntercept}`;
        }

        function calculateLineCoords(bulan1X, bulan1Y, bulan2X, bulan2Y) {
            const equation = linearEquation(bulan1X, bulan1Y, bulan2X, bulan2Y);
            console.log(equation); // Debug: Output the linear equation

            const slope = (bulan2Y - bulan1Y) / (bulan2X - bulan1X);
            const yIntercept = bulan1Y - slope * bulan1X;

            const x1 = (36 - yIntercept) / slope;
            const x2 = (-36 - yIntercept) / slope;

            return {
                x1: x1,
                x2: x2
            };
        }

//bagian bola 

// Define 3D coordinates for meridian and equator
      const meridianArray3D = [];
      const equatorArray3D = [];
      const paralelArray3D = [];
      const paralel2Array3D = [];
      const garistinggiArray3D = [];
      const garistinggi2Array3D = [];
      const radius = 500;
	// Define objectsToDraw
      const objectsToDraw = [];

        function bolaGhurubsatu() {
            objectsToDraw.length = 0;
            const altHilalsatu = altBulan11; //Math.floor(Math.random() * (36 - -36 + 1)) + -36;
            const altMataharisatu = altMatahari1; //Math.floor(Math.random() * (36 - -36 + 1)) + -36;
            const azmHilalsatu = azmBulan11; //Math.floor(Math.random() * (360 - 180 + 1)) + 180;
            const azmMataharisatu = azmMatahari1; //Math.floor(Math.random() * (360 - 180 + 1)) + 180;
	console.log("test, hallo");
      for (let y = 0; y <= 360; y++) {
        meridianArray3D.push({
          x: 0,
          y,
          z: radius
        });
        equatorArray3D.push({
          x: y,
          y: 0,
          z: radius
        });
        paralelArray3D.push({
          x: y,
          y: 60,
          z: radius
        });
        paralel2Array3D.push({
          x: y,
          y: -60,
          z: radius
        });
      }

     
        var b1 = 0;
      if (altHilalsatu <= 0) {
        b1 = altHilalsatu;
      }

      for (y = b1; y <= 90; y++) {
        garistinggiArray3D.push({
          x: azmHilalsatu,
          y,
          z: radius
        });
      }

       
        var m1 = 0;
      if (altMataharisatu <= 0) {
        m1 = altMataharisatu;
      }

      for ( y = m1; y <= 90; y++) {
        garistinggi2Array3D.push({
          x: azmMataharisatu,
          y,
          z: radius
        });
      }

    
  
      // Tambahkan lingkaran utama
      //objectsToDraw.push({ type: 'staticCircle', x: canvasWidth / 2, y: canvasHeight / 2 + 10, radius: radius/2, color: 'black', lineWidth: 2 });
      objectsToDraw.push({
        type: 'staticCircle',
        x: canvasWidth / 2,
        y: canvasHeight / 2 + 10,
        size: radius / 2,
        colorStop1: "#483D8B",
        colorStop2: "#C0C0C0"
      });
      // Tambahkan Object lingkaran equator
      objectsToDraw.push({
        type: "filledcurve",
        points: equatorArray3D,
        color: [47, 79, 79],
        alpha: 0.5,
        z: radius
      });
      // Tambahkan Object lingkaran equator
      objectsToDraw.push({
        type: "curve",
        points: equatorArray3D,
        color: "#FFFAF0",
        alpha: 01,
        z: radius
      });
      // Tambahkan Object teks horison
      objectsToDraw.push({
        type: 'text',
        x: 105,
        y: 0,
        z: 100,
        text: 'Horison',
        font: 'bold 16px Arial',
        color: 'orange'
      });
      // Tambahkan garis zenith
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: 0,
          y: 90,
          z: radius
        },
        color: "black"
      })
      // Tambahkan garis nadir
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: 0,
          y: -90,
          z: radius
        },
        color: "black"
      })
      // Tambahkan garis utara-selatan
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 180,
          y: 0,
          z: radius
        },
        endPoint: {
          x: 0,
          y: 0,
          z: radius
        },
        color: "red",
        lineWidth: 3
      });
      // Tambahkan garis barat-timur
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 90,
          y: 0,
          z: radius
        },
        endPoint: {
          x: 270,
          y: 0,
          z: radius
        },
        color: "green",
        lineWidth: 3
      });
      // Tambahkan titik pusat lingkaran
      objectsToDraw.push({
        type: 'point',
        x: 0,
        y: 0,
        color: 'black',
        z: 0
      });
      // Tambahkan titik utara
      objectsToDraw.push({
        type: 'point',
        x: 0,
        y: 0,
        color: 'black',
        z: radius
      });
      // Tambahkan titik timur
      objectsToDraw.push({
        type: 'point',
        x: 90,
        y: 0,
        color: 'black',
        z: radius
      });
      // Tambahkan titik selatan
      objectsToDraw.push({
        type: 'point',
        x: 180,
        y: 0,
        color: 'black',
        z: radius
      });
      // Tambahkan titik barat
      objectsToDraw.push({
        type: 'point',
        x: 270,
        y: 0,
        color: 'black',
        z: radius
      });
      // Tambahkan teks titik utara
      objectsToDraw.push({
        type: "text",
        x: 0,
        y: 3,
        text: "U",
        font: " bold 16px Arial",
        color: "red",
        z: radius
      });
      // Tambahkan teks titik selatan
      objectsToDraw.push({
        type: "text",
        x: 180,
        y: 3,
        text: "S",
        font: " bold 16px Arial",
        color: "red",
        z: radius
      });
      // Tambahkan teks titik timur
      objectsToDraw.push({
        type: "text",
        x: 90,
        y: 3,
        text: "T",
        font: " bold 16px Arial",
        color: "black",
        z: radius
      });
      // Tambahkan teks titik barat
      objectsToDraw.push({
        type: "text",
        x: 270,
        y: 3,
        text: "B",
        font: " bold 16px Arial",
        color: "black",
        z: radius
      });
      // Tambahkan teks titik zenit
      objectsToDraw.push({
        type: "text",
        x: 0,
        y: 90,
        text: "Z",
        font: " bold 16px Arial",
        color: "black",
        z: radius + 20
      });
      // Tambahkan teks titik nadir
      objectsToDraw.push({
        type: "text",
        x: 0,
        y: -90,
        text: "N",
        font: " bold 16px Arial",
        color: "black",
        z: radius + 40
      });
      // Tambahkan objek untuk gambar observatorium
      var obsPath = "https://onedrive.live.com/embed?resid=294AC1A521E5936D%216070&authkey=%21AFPVYaZ62AqTIb4";
      //objectsToDraw.push({ type: "image", x: canvasWidth / 2, y: canvasHeight / 2 + 10, image: obsPath, width: 30, height: 40, z: 60 });
      //objectsToDraw.push({ type: 'symbol', x: 0, y: 90, z: 70, symbol: '&#65039;', font: '20px Arial', color: 'purple' })
      //bagian untuk bulan
      // Tambahkan lingkaran tinggi bulan
      objectsToDraw.push({
        type: "curve",
        points: garistinggiArray3D,
        color: "#00FFFF",
        alpha: 0.5,
        z: radius
      });
      // Tambahkan garis datar bulan
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: azmHilalsatu,
          y: 0,
          z: radius - 20
        },
        color: "#00FFFF"
      });
      // Tambahkan garis tinggi bulan
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: azmHilalsatu,
          y: altHilalsatu,
          z: radius
        },
        color: "#00FFFF"
      });
      // Tambahkan objek untuk gambar bulan
      objectsToDraw.push({
        type: 'pointG',
        x: azmHilalsatu,
        y: altHilalsatu,
        size: 9,
        colorStop1: "#808080",
        colorStop2: "#FFEBCD",
        z: radius
      });
      // bagian untuk matahari
      // Tambahkan lingkaran tinggi matahari
      objectsToDraw.push({
        type: "curve",
        points: garistinggi2Array3D,
        color: "#7FFF00",
        alpha: 0.5,
        z: radius
      });
      // Tambahkan garis datar matahari
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: azmMataharisatu,
          y: 0,
          z: radius - 20
        },
        color: "#7FFF00"
      });
      // Tambahkan garis tinggi matahari
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: azmMataharisatu,
          y: altMataharisatu,
          z: radius
        },
        color: "#7FFF00"
      });
      // Tambahkan objek untuk gambar matahari
      objectsToDraw.push({
        type: 'pointG',
        x: azmMataharisatu,
        y: altMataharisatu,
        size: 11,
        colorStop1: "#FF4500",
        colorStop2: "yellow",
        z: radius
      });
      //bagian akhir
      // Tambahkan titik zenit
      objectsToDraw.push({
        type: 'point',
        x: 0,
        y: 90,
        color: 'black',
        z: radius
      });
      // Tambahkan titik nadir
      objectsToDraw.push({
        type: 'point',
        x: 0,
        y: -90,
        color: 'black',
        z: radius
      });
      // Gambar kembali semua objek setelah menambahkan objek garis
      draw(objectsToDraw);

}


//bola ghurub dua
function bolaGhurubdua() {
            objectsToDraw.length = 0;
            const altHilalsatu = altBulan21; //Math.floor(Math.random() * (36 - -36 + 1)) + -36;
            const altMataharisatu = altMatahari2; //Math.floor(Math.random() * (36 - -36 + 1)) + -36;
            const azmHilalsatu = azmBulan21; //Math.floor(Math.random() * (360 - 180 + 1)) + 180;
            const azmMataharisatu = azmMatahari2; //Math.floor(Math.random() * (360 - 180 + 1)) + 180;

      for (let y = 0; y <= 360; y++) {
        meridianArray3D.push({
          x: 0,
          y,
          z: radius
        });
        equatorArray3D.push({
          x: y,
          y: 0,
          z: radius
        });
        paralelArray3D.push({
          x: y,
          y: 60,
          z: radius
        });
        paralel2Array3D.push({
          x: y,
          y: -60,
          z: radius
        });
      }

     
        var b1 = 0;
      if (altHilalsatu <= 0) {
        b1 = altHilalsatu;
      }

      for (y = b1; y <= 90; y++) {
        garistinggiArray3D.push({
          x: azmHilalsatu,
          y,
          z: radius
        });
      }

       
        var m1 = 0;
      if (altMataharisatu <= 0) {
        m1 = altMataharisatu;
      }

      for ( y = m1; y <= 90; y++) {
        garistinggi2Array3D.push({
          x: azmMataharisatu,
          y,
          z: radius
        });
      }

    
  
      // Tambahkan lingkaran utama
      //objectsToDraw.push({ type: 'staticCircle', x: canvasWidth / 2, y: canvasHeight / 2 + 10, radius: radius/2, color: 'black', lineWidth: 2 });
      objectsToDraw.push({
        type: 'staticCircle',
        x: canvasWidth / 2,
        y: canvasHeight / 2 + 10,
        size: radius / 2,
        colorStop1: "#483D8B",
        colorStop2: "#C0C0C0"
      });
      // Tambahkan Object lingkaran equator
      objectsToDraw.push({
        type: "filledcurve",
        points: equatorArray3D,
        color: [47, 79, 79],
        alpha: 0.5,
        z: radius
      });
      // Tambahkan Object lingkaran equator
      objectsToDraw.push({
        type: "curve",
        points: equatorArray3D,
        color: "#FFFAF0",
        alpha: 01,
        z: radius
      });
      // Tambahkan Object teks horison
      objectsToDraw.push({
        type: 'text',
        x: 105,
        y: 0,
        z: 100,
        text: 'Horison',
        font: 'bold 16px Arial',
        color: 'orange'
      });
      // Tambahkan garis zenith
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: 0,
          y: 90,
          z: radius
        },
        color: "black"
      })
      // Tambahkan garis nadir
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: 0,
          y: -90,
          z: radius
        },
        color: "black"
      })
      // Tambahkan garis utara-selatan
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 180,
          y: 0,
          z: radius
        },
        endPoint: {
          x: 0,
          y: 0,
          z: radius
        },
        color: "red",
        lineWidth: 3
      });
      // Tambahkan garis barat-timur
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 90,
          y: 0,
          z: radius
        },
        endPoint: {
          x: 270,
          y: 0,
          z: radius
        },
        color: "green",
        lineWidth: 3
      });
      // Tambahkan titik pusat lingkaran
      objectsToDraw.push({
        type: 'point',
        x: 0,
        y: 0,
        color: 'black',
        z: 0
      });
      // Tambahkan titik utara
      objectsToDraw.push({
        type: 'point',
        x: 0,
        y: 0,
        color: 'black',
        z: radius
      });
      // Tambahkan titik timur
      objectsToDraw.push({
        type: 'point',
        x: 90,
        y: 0,
        color: 'black',
        z: radius
      });
      // Tambahkan titik selatan
      objectsToDraw.push({
        type: 'point',
        x: 180,
        y: 0,
        color: 'black',
        z: radius
      });
      // Tambahkan titik barat
      objectsToDraw.push({
        type: 'point',
        x: 270,
        y: 0,
        color: 'black',
        z: radius
      });
      // Tambahkan teks titik utara
      objectsToDraw.push({
        type: "text",
        x: 0,
        y: 3,
        text: "U",
        font: " bold 16px Arial",
        color: "red",
        z: radius
      });
      // Tambahkan teks titik selatan
      objectsToDraw.push({
        type: "text",
        x: 180,
        y: 3,
        text: "S",
        font: " bold 16px Arial",
        color: "red",
        z: radius
      });
      // Tambahkan teks titik timur
      objectsToDraw.push({
        type: "text",
        x: 90,
        y: 3,
        text: "T",
        font: " bold 16px Arial",
        color: "black",
        z: radius
      });
      // Tambahkan teks titik barat
      objectsToDraw.push({
        type: "text",
        x: 270,
        y: 3,
        text: "B",
        font: " bold 16px Arial",
        color: "black",
        z: radius
      });
      // Tambahkan teks titik zenit
      objectsToDraw.push({
        type: "text",
        x: 0,
        y: 90,
        text: "Z",
        font: " bold 16px Arial",
        color: "black",
        z: radius + 20
      });
      // Tambahkan teks titik nadir
      objectsToDraw.push({
        type: "text",
        x: 0,
        y: -90,
        text: "N",
        font: " bold 16px Arial",
        color: "black",
        z: radius + 40
      });
      // Tambahkan objek untuk gambar observatorium
      var obsPath = "https://onedrive.live.com/embed?resid=294AC1A521E5936D%216070&authkey=%21AFPVYaZ62AqTIb4";
      //objectsToDraw.push({ type: "image", x: canvasWidth / 2, y: canvasHeight / 2 + 10, image: obsPath, width: 30, height: 40, z: 60 });
      //objectsToDraw.push({ type: 'symbol', x: 0, y: 90, z: 70, symbol: '&#65039;', font: '20px Arial', color: 'purple' })
      //bagian untuk bulan
      // Tambahkan lingkaran tinggi bulan
      objectsToDraw.push({
        type: "curve",
        points: garistinggiArray3D,
        color: "#00FFFF",
        alpha: 0.5,
        z: radius
      });
      // Tambahkan garis datar bulan
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: azmHilalsatu,
          y: 0,
          z: radius - 20
        },
        color: "#00FFFF"
      });
      // Tambahkan garis tinggi bulan
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: azmHilalsatu,
          y: altHilalsatu,
          z: radius
        },
        color: "#00FFFF"
      });
      // Tambahkan objek untuk gambar bulan
      objectsToDraw.push({
        type: 'pointG',
        x: azmHilalsatu,
        y: altHilalsatu,
        size: 9,
        colorStop1: "#808080",
        colorStop2: "#FFEBCD",
        z: radius
      });
      // bagian untuk matahari
      // Tambahkan lingkaran tinggi matahari
      objectsToDraw.push({
        type: "curve",
        points: garistinggi2Array3D,
        color: "#7FFF00",
        alpha: 0.5,
        z: radius
      });
      // Tambahkan garis datar matahari
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: azmMataharisatu,
          y: 0,
          z: radius - 20
        },
        color: "#7FFF00"
      });
      // Tambahkan garis tinggi matahari
      objectsToDraw.push({
        type: "line",
        startPoint: {
          x: 0,
          y: 0,
          z: 0
        },
        endPoint: {
          x: azmMataharisatu,
          y: altMataharisatu,
          z: radius
        },
        color: "#7FFF00"
      });
      // Tambahkan objek untuk gambar matahari
      objectsToDraw.push({
        type: 'pointG',
        x: azmMataharisatu,
        y: altMataharisatu,
        size: 11,
        colorStop1: "#FF4500",
        colorStop2: "yellow",
        z: radius
      });
      //bagian akhir
      // Tambahkan titik zenit
      objectsToDraw.push({
        type: 'point',
        x: 0,
        y: 90,
        color: 'black',
        z: radius
      });
      // Tambahkan titik nadir
      objectsToDraw.push({
        type: 'point',
        x: 0,
        y: -90,
        color: 'black',
        z: radius
      });
      // Gambar kembali semua objek setelah menambahkan objek garis
      draw(objectsToDraw);

}

//kode pokok bola
      const canvas = document.getElementById("Canvas2");
      const ctx2 = canvas.getContext("2d");
      const sliderX = document.getElementById("sliderX");
      const sliderY = document.getElementById("sliderY");
      sliderY.value = -180; // Tetapkan nilai putaran Y pada -180
      const sliderZ = document.getElementById("sliderZ");
      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;
      // Dapatkan elemen canvas dan sliderX
      // Atur lebar sliderX sama dengan lebar canvas
      sliderX.style.height = canvas.width + "px";
      sliderZ.style.width = canvas.width + "px";
      canvas.addEventListener("touchmove", handleTouchMove);

      // Function to convert 3D coordinates to 2D
      function LongLatP2D(Longitude, Latitude, putaranX, putaranY, putaranZ, z) {
        let X3D;
        let Y3D;
        let Z3D;
        let XPutaranX;
        let YPutaranX;
        let ZPutaranX;
        let XPutaranY;
        let YPutaranY;
        let ZPutaranY;
        let XPutaranZ;
        let YPutaranZ;
        let ZPutaranZ;
        let XFINAL;
        let YFINAL;
        // Ubah Longitude dan Latitude menjadi koordinat XYZ
        X3D = -Math.sin(Rad(Longitude)) * Math.cos(Rad(Latitude)) * z;
        Y3D = Math.cos(Rad(Longitude)) * Math.cos(Rad(Latitude)) * z;
        Z3D = Math.sin(Rad(Latitude)) * z;
        // Putar dengan sumbu Z (putaran horizontal)
        XPutaranZ = X3D * Math.cos(Rad(putaranZ)) - Y3D * Math.sin(Rad(putaranZ));
        YPutaranZ = X3D * Math.sin(Rad(putaranZ)) + Y3D * Math.cos(Rad(putaranZ));
        ZPutaranZ = Z3D;
        // Putar dengan sumbu X (putaran vertikal)
        XPutaranX = XPutaranZ;
        YPutaranX = YPutaranZ * Math.cos(Rad(putaranX)) - ZPutaranZ * Math.sin(Rad(putaranX));
        ZPutaranX = YPutaranZ * Math.sin(Rad(putaranX)) + ZPutaranZ * Math.cos(Rad(putaranX));
        // Putar dengan sumbu Y
        XPutaranY = XPutaranX * Math.cos(Rad(putaranY)) + ZPutaranX * Math.sin(Rad(putaranY));
        YPutaranY = YPutaranX;
        ZPutaranY = -XPutaranX * Math.sin(Rad(putaranY)) + ZPutaranX * Math.cos(Rad(putaranY));
        // Perspektif dalam 2D
        const ES = -5000; // Perspektif
        const SO = -5000; // Panjang sumbu Z
        XFINAL = (XPutaranY * ES) / (ES + SO + ZPutaranY) + canvasWidth / 2;
        YFINAL = (ZPutaranY * ES) / (ES + SO + ZPutaranY) + canvasHeight / 2;
        return {
          x: XFINAL,
          y: YFINAL
        };
      }
      // Function to clear canvas
      function clearCanvas() {
        ctx2.clearRect(0, 0, canvas.width, canvas.height);
      }
      // Function to draw objects based on 3D coordinates
      function draw(objects) {
        clearCanvas();
        objects.forEach((object) => {
		iconuwong();
          switch (object.type) {
            // Case for drawing static circle
            case "staticCircle":
              //drawStaticCircle(object.x, object.y, object.radius, object.color, object.lineWidth);
              drawPointG2(object.x, object.y, object.size, object.colorStop1, object.colorStop2); // Gradien diteruskan sebagai argumen
              break;
              break;
            case "point":
              const rotatedPoint = LongLatP2D(object.x, object.y, sliderX.value, sliderY.value, sliderZ.value, object.z);
              drawPoint(rotatedPoint.x, rotatedPoint.y, object.color);
              break;
            case "pointG":
              const rotatedPointG = LongLatP2D(object.x, object.y, sliderX.value, sliderY.value, sliderZ.value, object.z);
              drawPointG2(rotatedPointG.x, rotatedPointG.y, object.size, object.colorStop1, object.colorStop2); // Gradien diteruskan sebagai argumen
              break;
            case "symbol":
              const rotatedSymbol = LongLatP2D(object.x, object.y, sliderX.value, sliderY.value, sliderZ.value, object.z);
              drawSymbol(rotatedSymbol.x, rotatedSymbol.y, object.symbol, object.font, object.color);
              break;
            case "image":
              const rotatedImg = LongLatP2D(object.x, object.y, sliderX.value, sliderY.value, sliderZ.value, object.z);
              //drawImg(rotatedImg.x, rotatedImg.y, object.image, object.width, object.height);
              drawImg(object.x, object.y, object.image, object.width, object.height);
              break;
            case "text":
              const rotatedText = LongLatP2D(object.x, object.y, sliderX.value, sliderY.value, sliderZ.value, object.z);
              drawText(rotatedText.x, rotatedText.y, object.text, object.font, object.color);
              break;
            case "curve":
              const rotatedCurvePoints = object.points.map((point3D) => {
                return LongLatP2D(point3D.x, point3D.y, sliderX.value, sliderY.value, sliderZ.value, object.z);
              });
              drawCurve(rotatedCurvePoints, object.color);
              break;
            case "filledcurve":
              const rotatedfilledCurvePoints = object.points.map((point3D) => {
                return LongLatP2D(point3D.x, point3D.y, sliderX.value, sliderY.value, sliderZ.value, object.z);
              });
              drawFilledCurve(rotatedfilledCurvePoints, object.color, object.alpha);
              break;
            case "staticfilledcurve":
              drawFilledCurve(pointss, object.color, object.alpha);
              break;
            case "line":
              const startPoint = LongLatP2D(object.startPoint.x, object.startPoint.y, sliderX.value, sliderY.value, sliderZ.value, object.startPoint.z);
              const endPoint = LongLatP2D(object.endPoint.x, object.endPoint.y, sliderX.value, sliderY.value, sliderZ.value, object.endPoint.z);
              drawLine2(startPoint, endPoint, object.color, object.lineWidth);
              break;
            default:
              break;
          }
	
        });
	//alert("hai");
      
	
      }


      // Function to draw a point with customizable size and gradient
      function drawPointG2(x, y, size, colorStop1, colorStop2) {
        const ctx2 = canvas.getContext("2d");
        // Create radial gradient with updated position
        const radialGradient = ctx2.createRadialGradient(x, y, 0, x, y, size);
        radialGradient.addColorStop(0, colorStop1 || "red"); // Warna tengah
        radialGradient.addColorStop(1, colorStop2 || "yellow"); // Warna pinggiran
        // Gunakan gradien yang baru untuk menggambar objek
        ctx2.fillStyle = radialGradient;
        ctx2.beginPath();
        ctx2.arc(x, y, size || 5, 0, Math.PI * 2);
        ctx2.fill();
      }
      // Function to draw an image
      function drawImg(x, y, imageSrc, width, height) {
        const img = new Image();
        img.onload = function() {
          // Gambar di tengah dengan menggeser titik awal (x, y) ke koordinat tengah kanvas
          const newX = x - width / 2;
          const newY = y - height / 2;
          ctx2.drawImage(img, newX, newY, width, height);
        };
        img.src = imageSrc;
      }
      // Function to draw a static circle
      function drawStaticCircle(x, y, radius, color, lineWidth) {
        ctx2.strokeStyle = color || 'black';
        ctx2.lineWidth = lineWidth || 1;
        ctx2.beginPath();
        ctx2.arc(x, y, radius, 0, 2 * Math.PI);
        ctx2.stroke();
      }
      // Function to draw a line
      function drawLine2(startPoint, endPoint, color, lineWidth) {
        ctx2.strokeStyle = color || "black"; // Default color black
        ctx2.lineWidth = lineWidth || 1; // Default line width 1
        ctx2.beginPath();
        ctx2.moveTo(startPoint.x, startPoint.y);
        ctx2.lineTo(endPoint.x, endPoint.y);
        ctx2.stroke();
      }
      // Function to draw a curve
      function drawCurve(points, color, lineWidth) {
        ctx2.strokeStyle = color || "black"; // Default color black
        ctx2.lineWidth = lineWidth || 1; // Default line width 1
        ctx2.beginPath();
        ctx2.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx2.lineTo(points[i].x, points[i].y);
        }
        ctx2.stroke();
      }
      // Function to draw a filled curve with transparency
      function drawFilledCurve(points, color, alpha, lineWidth) {
        ctx2.fillStyle = `rgba(${color.join(",")},${alpha})`; // Color with alpha
        ctx2.lineWidth = lineWidth || 1; // Default line width 1
        ctx2.beginPath();
        ctx2.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx2.lineTo(points[i].x, points[i].y);
        }
        ctx2.closePath(); // Close the path
        ctx2.fill(); // Fill the curve with color and transparency
      }
      // Function to draw a point
      function drawPoint(x, y, color) {
        ctx2.fillStyle = color || "black";
        ctx2.beginPath();
        ctx2.arc(x, y, 5, 0, Math.PI * 2);
        ctx2.fill();
      }
      // Function to draw a symbol with correct position
      function drawSymbol(x, y, symbol, font, color) {
        ctx2.fillStyle = color || 'black';
        ctx2.font = font || '12px Arial';
        // Measure text to get width and height of the symbol
        const textMetrics = ctx2.measureText(symbol);
        const symbolWidth = textMetrics.width;
        const symbolHeight = parseInt(ctx2.font); // Assume font size is the height
        // Calculate the adjusted position
        const adjustedX = x - symbolWidth / 2; // Adjust x to center
        const adjustedY = y + symbolHeight / 2; // Adjust y to center vertically
        // Draw the symbol at the adjusted position
        ctx2.fillText(symbol, adjustedX, adjustedY);
      }
      // Function to draw text
      function drawText(x, y, text, font, color) {
        ctx2.fillStyle = color || "black";
        ctx2.font = font || "bold 12px Arial";
        ctx2.fillText(text, x, y);
      }

	 // Menggambar ikon "fa-male" di tengah-tengah canvas
  var iconSize = 48; // Ukuran ikon
  var xuwong = 10 + (canvas.width - iconSize) / 2; // Menghitung posisi x
  var yuwong = (canvas.height - iconSize) / 2; // Menghitung posisi y
  
 function iconuwong() {
  ctx2.fillStyle = "yellow"; // Warna ikon
  ctx2.font = iconSize + "px FontAwesome"; // Ukuran dan jenis ikon
  ctx2.fillText("\uf183", xuwong, yuwong); // Menggambar ikon menggunakan Unicode Font Awesome
}


      // Function to convert degrees to radians
      function Rad(degrees) {
        return degrees * (Math.PI / 180);
      }
      // Event listeners for sliders
      sliderX.addEventListener("input", function() {
        draw(objectsToDraw);
      });
      //sliderY.addEventListener("input", function () {
      //    draw(objectsToDraw);
      //});
sliderZ.addEventListener("input", function() {
  // Ambil nilai dari sliderZ
  let value = parseInt(this.value);

  // Jika nilai sliderZ adalah 180, ubah menjadi -180
  if (value === 180) {
    this.value = -180;
  }

  // Jika nilai sliderZ adalah -181, ubah menjadi 179
  if (value === -181) {
    this.value = 179;
  }

  // Panggil fungsi draw(objectsToDraw)
  draw(objectsToDraw);
});
      // Variabel untuk menyimpan nilai top dan left terakhir dari sentuhan atau mouse
      let lastTop = null;
      let lastLeft = null;
      // Batasan pergerakan maksimum per sentuhan atau mouse
      const maxAngle = 90; // Atur maksimum sudut yang diizinkan
      // Fungsi untuk menangani pergerakan sentuhan
      function handleTouchMove(event) {
        const rect = canvas.getBoundingClientRect();
        const touchX = event.touches[0].clientX - rect.left;
        const touchY = event.touches[0].clientY - rect.top;
        handleMovement(touchX, touchY);
      }
      // Fungsi untuk menangani pergerakan mouse
      function handleMouseMove(event) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;
        handleMovement(mouseX, mouseY);
      }
      // Fungsi untuk menangani pergerakan baik dari sentuhan maupun mouse
      function handleMovement(x, y) {
        if (lastTop === null || lastLeft === null) {
          lastTop = y;
          lastLeft = x;
          return; // Keluar dari fungsi jika ini adalah sentuhan pertama atau gerakan mouse pertama
        }
        // Hitung pergerakan dari posisi sentuhan atau mouse sebelumnya
        const movementX = x - lastLeft;
        const movementY = y - lastTop;
        // Hitung pergerakan yang valid berdasarkan batasan maksimum
        const validMovementX = Math.min(Math.max(movementX, -maxAngle), maxAngle);
        const validMovementY = Math.min(Math.max(movementY, -maxAngle), maxAngle);
        // Hitung nilai baru untuk sliderX.value dan sliderZ.value
        let newXValue = parseFloat(sliderX.value) + (validMovementY / canvas.width) * 2 * maxAngle;
        let newZValue = parseFloat(sliderZ.value) + (validMovementX / canvas.height) * 2 * maxAngle;
        // Batasi nilai sliderX.value dan sliderZ.value dalam rentang -180 hingga 180
        newXValue = Math.min(Math.max(newXValue, -180), 180);
        newZValue = Math.min(Math.max(newZValue, -180), 180);
        // Update nilai sliderX.value dan sliderZ.value
        //sliderX.value = newXValue.toFixed(2); // Pembulatan angka desimal
        sliderZ.value = newZValue.toFixed(2);
        // Simpan nilai top dan left untuk digunakan di sentuhan atau mouse selanjutnya
        lastTop = y;
        lastLeft = x;
        // Gambar ulang objek berdasarkan nilai slider baru
        draw(objectsToDraw);
      }
      // Tambahkan event listener untuk pergerakan sentuhan
      canvas.addEventListener("touchmove", handleTouchMove);
      // Tambahkan event listener untuk pergerakan mouse
      canvas.addEventListener("mousemove", handleMouseMove);
        
        
        
        
        
        
        
        
        

	//Berikut fungsi-fungsi rutin 
//============================//
//Fungsi ini digunakan untuk menghitung Julian Day dari sebuah tanggal dan waktu dalam format Tanggal, Bulan, Tahun, Jam Desimal, dan Timezone. 
//Fungsi ini menerima 5 parameter, yaitu Tanggal (TglM), Bulan (BlnM), Tahun (ThnM), Jam Desimal (JamDes), dan Timezone (TimeZone).
//Fungsi ini berguna untuk menghitung Julian Day dari sebuah tanggal dan waktu dalam aplikasi astronomi atau astrologi. 
//Julian Day adalah sistem penanggalan yang digunakan oleh para ahli astronomi untuk menyederhanakan perhitungan tanggal dan waktu 
//dalam observasi astronomi.

function KMJD(TglM, BlnM, ThnM, JamDes = 0, TimeZone = 0) {
  // Deklarasi Variabel dan Tipe Variabel
  let DDUT, MM, YM, a, b, JD;
  // Proses Perhitungan
  // Tanggal dan Jam Desimal Lokal ke Tanggal Desimal UT
  DDUT = TglM + ((JamDes - TimeZone) / 24);
  // Penyesuaian Bulan dan Tahun untuk memudahkan perhitungan
  if (BlnM > 2) {
    MM = BlnM; YM = ThnM;
  } else {
    MM = BlnM + 12; YM = ThnM - 1;
  }
  // Koreksi Paus Gregorius berlaku sejak tanggal 15 Oktober 1582 M
  if ((ThnM + BlnM / 100 + TglM / 10000) >= 1582.1015) {
    a = Math.floor(YM / 100); b = 2 - a + Math.floor(a / 4);
  } else {
    a = 0; b = 0;
  }
  // Perhitungan Julian Day tahap akhir
  JD = Math.floor(365.25 * (YM + 4716)) + Math.floor(30.6001 * (MM + 1)) + DDUT + b - 1524.5;
  // Hasil Perhitungan
  return JD;
}


//Ini adalah sebuah fungsi bernama JDKM yang digunakan untuk mengonversi tanggal Julian menjadi tanggal Gregorian (Kalender Barat). 
//Fungsi ini mengambil tiga argumen: tanggal Julian (JD), zona waktu (TimeZone) dan opsi hasil (OptResult).
//Fungsi ini melakukan beberapa perhitungan matematika untuk mengonversi tanggal Julian menjadi tanggal Gregorian. 
//fungsi akan mengembalikan hasil dalam bentuk format tertentu, seperti nama hari, pasaran, tanggal, bulan, tahun, dan sebagainya,
//tergantung pada opsi hasil yang diberikan. Ada juga beberapa variabel yang digunakan dalam perhitungan, seperti CJD, Z, F, JamDes, 
//Alpha, a, b, c, D, E, TglM, BlnM, ThnM, ThnMAYNS, ThnMHYNS, NmBlnMDt, NmBlnM, NoHrM, NmHrMDt, NmPsMDt, NmHrM, NmPsM, dan Hasil.

function JDKM(JD, TimeZone = 0, OptResult = '') {
  // Declare variables and their types
  let CJD = 0;
  let Z = 0;
  let F = 0;
  let JamDes = 0;
  let Alpha = 0;
  let a = 0;
  let b = 0;
  let c = 0;
  let D = 0;
  let E = 0;
  let TglM = 0;
  let BlnM = 0;
  let ThnM = 0;
  let ThnMAYNS = '';
  let ThnMHYNS = '';
 // let NmBlnMDt = [];
 //let NmBlnM = '';
 // let NoHrM = 0;
 // let NmHrMDt = [];
 // let NmHrM = '';
//  let NoPsM = 0;
 // let NmPsMDt = [];
 //let NmPsM = '';
 // let Result = '';

  // Calculations
  // Convert to Chronological Julian Day, Chronological Julian Day Number,
  // Fractional Part of the Day, and Decimal Time
  CJD = JD + 0.5 + (TimeZone / 24);
  Z = Math.floor(CJD);
  F = CJD - Z;
  JamDes = F * 24;

  // Correction of Gregorian Pause calculation
  if (Z >= 2298161) {
    Alpha = Math.floor((Z - 1867216.25) / 36524.25);
    a = Z + 1 + Alpha - Math.floor(Alpha / 4);
  } else {
    Alpha = 0;
    a = Z;
  }

  // Core calculation
  b = a + 1524;
  c = Math.floor((b - 122.1) / 365.25);
  D = Math.floor(365.25 * c);
  E = Math.floor((b - D) / 30.6001);

  // Determine the date, month, and year of the Gregorian calendar
  TglM = b - D - Math.floor(30.6001 * E);
  if (E < 14) {
    BlnM = E - 1;
  } else if (E === 14 || E === 15) {
    BlnM = E - 13;
  }
  if (BlnM > 2) {
    ThnM = c - 4716;
  } else if (BlnM === 1 || BlnM === 2) {
    ThnM = c - 4715;
  }

  // ThnMAYNS = Gregorian year with Astronomical Year Numbering System
  // Thnmhyns = Gregorian year with Historical Year Numbering System
  if (ThnM > 0) {
    ThnMHYNS = ThnM + ' M';
    ThnMAYNS = '+' + ThnM;
  } else {
    ThnMHYNS = Math.abs(ThnM) + 1 + ' SM';
    ThnMAYNS = ThnM;
  }

 
  // Penentuan Nama Bulan Miladi
  var NmBlnMDt = ["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "November", "Desember"];
  var NmBlnM = NmBlnMDt[BlnM - 1];

  // Penentuan Nama Hari dan Pasaran Berdasarkan Kalender Miladi
  var NoHrM = Z - 7 * Math.floor(Z / 7);
  var NoPsM = Z - 5 * Math.floor(Z / 5);
  var NmHrMDt = ["Senin", "Selasa", "Rabu", "Kamis", "Jum'at", "Sabtu", "Minggu"];
  var NmPsMDt = ["Legi", "Pahing", "Pon", "Wage", "Kliwon"];
  var NmHrM = NmHrMDt[NoHrM];
  var NmPsM = NmPsMDt[NoPsM];

  // Penentuan Format Hasil Perhitungan
  var Result;
  switch (OptResult.toUpperCase().replace(/ /g, "")) {
    case "":
      Result = NmHrM + " " + NmPsM + ", " + TglM + " " + NmBlnM + " " + ThnMHYNS;
      break;
    case "JAMDES":
      Result = JamDes;
      break;
    case "PECAHANHARI":
      Result = F;
      break;
    case "TGLM":
    case "TGL":
      Result = TglM;
      break;
    case "BLNM":
    case "BLN":
      Result = BlnM;
      break;
    case "NMBLNM":
      Result = NmBlnM;
      break;
    case "THNM":
    case "THN":
      Result = ThnM;
      break;
    case "THNMAYNS":
      Result = ThnMAYNS;
      break;
    case "THNMHYNS":
      Result = ThnMHYNS;
      break;
    case "HARI":
    case "HR":
      Result = NmHrM;
      break;
    case "PASARAN":
    case "PS":
      Result = NmPsM;
      break;
    case "HARIPASARAN":
      Result = NmHrM + " " + NmPsM;
      break;
      case "TGLBLNTHN":
      Result = TglM + " " + NmBlnM + " " + ThnM;
      break;
    default:
      Result = NmHrM + " " + NmPsM + ", " + TglM + " " + NmBlnM + " " + ThnMHYNS;
  }

  // Hasil Perhitungan
  return Result;
}



// fungsi Deg to Rad, rad to deg deci to DDMS modFDiv

 // Fungsi untuk mengubah radian ke derajat
      function radToDeg(rad) {
        return rad * (180 / Math.PI);
      }

      // Fungsi untuk mengubah derajat ke radian
      function degToRad(deg) {
        return deg * (Math.PI / 180);
      }
      
	// DDDMS adalah sebuah fungsi JavaScript untuk mengkonversi  dari format desimal menjadi format derajat-menit-detik (DMS). 
  //Fungsi ini menerima dua parameter, yaitu koordinat desimal yang akan dikonversi dan opsi hasil yang dapat ditentukan oleh pengguna.
  //Fungsi ini menghitung derajat, menit, dan detik dari koordinat desimal, kemudian mengembalikan hasil dalam format DMS 
  //dengan simbol derajat, menit, dan detik. Fungsi ini juga mendukung opsi hasil, yaitu "L" untuk menambahkan penanda arah utara/selatan, 
  //atau "B" untuk menambahkan penanda arah timur/barat pada hasil konversi.

function DDDMS(decimals, OptResult="") {
  var Result="";
  let decimal = Math.abs(decimals);
  var degrees = Math.floor(decimal);
  var minutes = Math.floor((decimal - degrees) * 60);
  var seconds = (((decimal - degrees) * 60 - minutes) * 60).toFixed(3);

switch (OptResult.replace(/\s/g, "").toUpperCase()) {
  case "":
    Result = (decimals >= 0 ? degrees : "- " + degrees) + "&#176; " + 
    (minutes < 10 ? "0" + minutes : minutes) + "' " + 
    (seconds < 10 ? "0" + seconds : seconds) + "''";
    break; // tambahkan break di sini

  case "L":
    if (decimals < 0) {
      Result = degrees + "&#176; " + 
        (minutes < 10 ? "0" + minutes : minutes) + "' " + 
        (seconds < 10 ? "0" + seconds : seconds) + "''" + " LS";
    } else {
      Result = degrees + "&#176; " + 
        (minutes < 10 ? "0" + minutes : minutes) + "' " + 
        (seconds < 10 ? "0" + seconds : seconds) + "''" + " LU";
    }
    break;

  case "B":
    if (decimals < 0) {
      Result = degrees + "&#176; " + 
        (minutes < 10 ? "0" + minutes : minutes) + "' " + 
        (seconds < 10 ? "0" + seconds : seconds) + "''" + " BB";
    } else {
      Result = degrees + "&#176; " + 
        (minutes < 10 ? "0" + minutes : minutes) + "' " + 
        (seconds < 10 ? "0" + seconds : seconds) + "''" + " BT";
    }
    break;

  default:
    Result = (decimals >= 0 ? degrees : "- " + degrees) + "&#176; " + 
    (minutes < 10 ? "0" + minutes : minutes) + "' " + 
    (seconds < 10 ? "0" + seconds : seconds) + "''";
    break;
}
return Result;
}

//DHHMS ini digunakan untuk mengonversi waktu dalam bentuk desimal jam menjadi format jam:menit:detik atau durasi waktu.

function DHHMS(decimalHourss, OptResult="") {
	var Result;
  var decimalHours =Math.abs(decimalHourss);
  var hours = Math.floor(decimalHours);
  var minutes = Math.floor((decimalHours - hours) * 60);
  var seconds = (((decimalHours - hours) * 60) - minutes) * 60;

  var formattedHours = hours.toString().padStart(2, '0');
  var formattedMinutes = minutes.toString().padStart(2, '0');
  var formattedSeconds = seconds.toFixed(3).toString().padStart(6, '0');
  var tanda ="";
  if (Math.sign(decimalHourss)== -1){
    tanda = "- ";
    tanda2 = "kurang ";
  };
	switch (OptResult.replace(/\s/g, "").toUpperCase()) {
	case "":
    Result = tanda + formattedHours + ':' + formattedMinutes + ':' + formattedSeconds;
	break;
	case "DURASI":
    Result = tanda + formattedHours + ' jam ' + formattedMinutes + ' menit ' + formattedSeconds + " detik";
    break;
    default:
    Result = tanda + formattedHours + ':' + formattedMinutes + ':' + formattedSeconds;
	break;

	}
  return Result;
}

   
// fungsi untuk pembagian modulo (sisa bagi)
function ModFDiv(dividend, divisor) {
  return dividend - divisor * Math.floor(dividend / divisor);
}
      
// Fungsi "azimuthWithCosine" digunakan untuk menghitung arah sudut antara dua titik koordinat pada permukaan bumi menggunakan rumus kosinus.
//Fungsi ini membutuhkan empat parameter, yaitu lat1 (garis lintang titik awal), long1 (garis bujur titik awal), lat2 (garis lintang titik akhir),
//dan long2 (garis bujur titik akhir).
//Pertama, fungsi ini menghitung selisih bujur antara titik awal dan titik akhir. Selisih ini kemudian diubah ke dalam rentang 0-360 derajat 
//dengan menggunakan fungsi ModFDiv.
//Kemudian, semua parameter diubah dari satuan derajat menjadi satuan radian menggunakan fungsi degToRad. 
//Selanjutnya, jarak antara kedua titik koordinat dihitung menggunakan rumus kosinus.
//Setelah itu, fungsi ini menghitung arah sudut antara dua titik koordinat menggunakan rumus kosinus dan tangen. Hasilnya 
//kemudian dikonversi ke dalam satuan derajat menggunakan fungsi radToDeg.
//Jika selisih bujur lebih besar dari 180 derajat, maka hasil arah sudut akan dikoreksi dengan menguranginya dari 360 derajat.
//Akhirnya, fungsi ini mengembalikan nilai arah sudut dalam satuan derajat.

        function azimuthWithCosine(lat1, long1, lat2, long2) {
        var selisihLong = (long1 + 180) - (long2 + 180);
        
       selisihLong = ModFDiv(selisihLong , 360);
	  /selisihLong = degToRad(selisihLong);/
        lat1 = degToRad(lat1);
        long1 = degToRad(long1);
        lat2 = degToRad(lat2);
        long2 = degToRad(long2);
        var jarak = Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(degToRad(selisihLong)));
        var azimuthWithCos = Math.acos(-Math.tan(lat2) / Math.tan(jarak) + Math.sin(lat1) / Math.cos(lat2) / Math.sin(jarak));
	  azimuthWithCos = radToDeg(azimuthWithCos)
        if (selisihLong > 180) {
          azimuthWithCos = 360 - azimuthWithCos;
        }
        return azimuthWithCos;
      }





// Fungsi Deltat adalah sebuah fungsi JavaScript yang digunakan untuk menghitung nilai Delta T (perbedaan waktu atom dan waktu astronomi)
// berdasarkan Julian Day. Delta T adalah selisih antara waktu atom (waktu yang ditentukan berdasarkan getaran atom) dan waktu astronomi
// (waktu yang ditentukan berdasarkan rotasi Bumi). Fungsi ini memiliki beberapa variabel yang digunakan dalam perhitungan,
// seperti TlM (tahun), JDTlMAw (Julian Day dari awal tahun), JDTlMAk (Julian Day dari akhir tahun), JHrlTlM (jumlah hari dari awal tahun),
// JHrTlM (jumlah hari dalam setahun), dY (tahun desimal), kU, kT (variabel lain yang digunakan dalam perhitungan). 
//Kemudian, fungsi menggunakan serangkaian pernyataan kondisional (if-else) untuk menghitung nilai Delta T berdasarkan tahun desimal.

function Deltat(JD) {
  let TlM = 0;
  let JDTlMAw = 0;
  let JDTlMAk = 0;
  let JHrlTlM = 0;
  let JHrTlM = 0;
  let dY = 0;
  let kU = 0;
  let kT = 0;
  let DltT = 0;
  let sCorr = 0;
  
  TlM = JDKM(JD, 0, "ThnM");
  JDTlMAw = KMJD(1, 1, TlM, 0, 0);
  JDTlMAk = KMJD(31, 12, TlM, 24, 0);
  JHrlTlM = JD - JDTlMAw;
  JHrTlM = JDTlMAk - JDTlMAw;
  dY = TlM + JHrlTlM / JHrTlM;
  
  if (dY <= -500) {
    kU = (dY - 1820) / 100;
    DltT = -20 + 32 * kU * kU;
  } else if (dY > -500 && dY <= 500){
    kU = dY / 100;
    DltT = 10583.6 - 1014.41 * kU + 33.78311 * kU * kU - 5.952053 * kU * kU * kU - 0.1798452 * kU * kU * kU * kU + 0.022174192 * Math.pow(kU, 5) + 0.0090316521 * Math.pow(kU, 6);
  } else if (dY > 500 && dY <= 1600){
    kU = (dY - 1000) / 100;
    DltT = 1574.2 - 556.01 * kU + 71.23472 * kU * kU + 0.319781 * kU * kU * kU - 0.8503463 * kU * kU * kU * kU - 0.005050998 * Math.pow(kU, 5) + 0.0083572073 * Math.pow(kU, 6);
  } else if (dY > 1600 && dY <= 1700){
    kT = dY - 1600;
    DltT = 120 - 0.9808 * kT - 0.01532 * kT * kT + kT * kT * kT / 7129;
  } else if (dY > 1700 && dY <= 1800){
    kT = dY - 1700;
    DltT = 8.83 + 0.1603 * kT - 0.0059285 * kT * kT + 0.00013336 * Math.pow(kT, 3) - Math.pow(kT, 4) / 1174000;
  } else if (dY > 1800 && dY <= 1860) {
    kT = dY - 1800;
    DltT = 13.72 - 0.332447 * kT + 0.0068612 * kT * kT + 0.0041116 * kT * kT * kT - 0.00037436 * kT * kT * kT * kT + 0.0000121272 * kT * kT * kT * kT * kT - 0.0000001699 * kT * kT * kT * kT * kT * kT + 0.000000000875 * kT * kT * kT * kT * kT * kT * kT;

  } else if (dY > 1860 && dY <= 1900) {
    kT = dY - 1860;
    DltT = 7.62 + 0.5737 * kT - 0.251754 * kT * kT + 0.01680668 * kT * kT * kT - 0.0004473624 * kT * kT * kT * kT + kT * kT * kT * kT * kT / 233174;
  } else if (dY > 1900 && dY <= 1920) {
    kT = dY - 1900;
    DltT = -2.79 + 1.494119 * kT - 0.0598939 * kT * kT + 0.0061966 * kT * kT * kT - 0.000197 * kT * kT * kT * kT;
  } else if (dY > 1920 && dY <= 1941) {
    kT = dY - 1920;
    DltT = 21.2 + 0.84493 * kT - 0.0761 * kT * kT + 0.0020936 * kT * kT * kT;
  } else if (dY > 1941 && dY <= 1961) {
    kT = dY - 1950;
    DltT = 29.07 + 0.407 * kT - kT * kT / 233 + kT * kT * kT / 2547;
  } else if (dY > 1961 && dY <= 1986) {
    kT = dY - 1975;
    DltT = 45.45 + 1.067 * kT - kT * kT / 260 - kT * kT * kT / 718;
  } else if (dY > 1986 && dY <= 2005) {
    kT = dY - 2000;
   
        DltT = 63.86 + 0.3345 * kT - 0.060374 * kT * kT  + 0.0017275 * kT * kT * kT  + 0.000651814 * kT * kT * kT * kT  + 0.00002373599 * kT * kT * kT * kT * kT ;
    } else if (dY > 2005 && dY <= 2050){
        kT = dY - 2000;
        DltT = 62.92 + 0.32217 * kT + 0.005589 * kT * kT ;
    } else if (dY > 2050 && dY <= 2150){
        DltT = -20 + 32 * ((dY - 1820) / 100) * ((dY - 1820) / 100) - 0.5628 * (2150 - dY);
    } else if (dY > 2150) {
        kU = (dY - 1820) / 100;
        DltT = -20 + 32 * kU * kU;
    }
    if (dY < 1955 || dY > 2005) {
    sCorr = -0.000012932 * Math.pow(dY - 1955, 2);
    DltT += sCorr;
  } else {
    sCorr = 0;
    DltT = DltT;
  }
  return DltT;
}


    // data matahari

      function NutationInLongitude(JD) {
  let T = (JD - 2451545) / 36525;
  let D = 297.85036 + 445267.11148 * T - 0.0019142 * Math.pow(T, 2) + Math.pow(T, 3) / 189474;
  let M = 357.52772 + 35999.05034 * T - 0.0001603 * Math.pow(T, 2) - Math.pow(T, 3) / 300000;
  let M_ = 134.96298 + 477198.867398 * T + 0.0086972 * Math.pow(T, 2) + T * 3 / 56250;
  let F = 93.27191 + 483202.017538 * T - 0.0036825 * Math.pow(T, 2) + Math.pow(T, 3) / 327270;
  let Omg = 125.04452 - 1934.136261 * T + 0.0020708 * Math.pow(T, 2) + Math.pow(T, 3) / 450000;
    D = degToRad(ModFDiv(D, 360));
    M = degToRad(ModFDiv(M, 360));
    M_ = degToRad(ModFDiv( M_, 360));
    F = degToRad(ModFDiv(F, 360));
    Omg = degToRad(ModFDiv(Omg, 360));
    let DltPsi = 0;
    DltPsi += (-171996 + -174.2 * T) * Math.sin(0 * D + 0 * M + 0 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (-13187 + -1.6 * T) * Math.sin(-2 * D + 0 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-2274 + -0.2 * T) * Math.sin(0 * D + 0 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (2062 + 0.2 * T) * Math.sin(0 * D + 0 * M + 0 *  M_ + 0 * F + 2 * Omg);;
    DltPsi += (1426 + -3.4 * T) * Math.sin(0 * D + 1 * M + 0 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (712 + 0.1 * T) * Math.sin(0 * D + 0 * M + 1 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (-517 + 1.2 * T) * Math.sin(-2 * D + 1 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-386 + -0.4 * T) * Math.sin(0 * D + 0 * M + 0 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (-301 + 0 * T) * Math.sin(0 * D + 0 * M + 1 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (217 + -0.5 * T) * Math.sin(-2 * D + -1 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-158 + 0 * T) * Math.sin(-2 * D + 0 * M + 1 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (129 + 0.1 * T) * Math.sin(-2 * D + 0 * M + 0 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (123 + 0 * T) * Math.sin(0 * D + 0 * M + -1 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (63 + 0 * T) * Math.sin(2 * D + 0 * M + 0 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (63 + 0.1 * T) * Math.sin(0 * D + 0 * M + 1 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (-59 + 0 * T) * Math.sin(2 * D + 0 * M + -1 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-58 + -0.1 * T) * Math.sin(0 * D + 0 * M + -1 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (-51 + 0 * T) * Math.sin(0 * D + 0 * M + 1 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (48 + 0 * T) * Math.sin(-2 * D + 0 * M + 2 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (46 + 0 * T) * Math.sin(0 * D + 0 * M + -2 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (-38 + 0 * T) * Math.sin(2 * D + 0 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-31 + 0 * T) * Math.sin(0 * D + 0 * M + 2 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (29 + 0 * T) * Math.sin(0 * D + 0 * M + 2 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (29 + 0 * T) * Math.sin(-2 * D + 0 * M + 1 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (26 + 0 * T) * Math.sin(0 * D + 0 * M + 0 *  M_ + 2 * F + 0 * Omg);;
    DltPsi += (-22 + 0 * T) * Math.sin(-2 * D + 0 * M + 0 *  M_ + 2 * F + 0 * Omg);;
    DltPsi += (21 + 0 * T) * Math.sin(0 * D + 0 * M + -1 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (17 + -0.1 * T) * Math.sin(0 * D + 2 * M + 0 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (16 + 0 * T) * Math.sin(2 * D + 0 * M + -1 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (-16 + 0.1 * T) * Math.sin(-2 * D + 2 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-15 + 0 * T) * Math.sin(0 * D + 1 * M + 0 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (-13 + 0 * T) * Math.sin(-2 * D + 0 * M + 1 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (-12 + 0 * T) * Math.sin(0 * D + -1 * M + 0 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (11 + 0 * T) * Math.sin(0 * D + 0 * M + 2 *  M_ + -2 * F + 0 * Omg);;
    DltPsi += (-10 + 0 * T) * Math.sin(2 * D + 0 * M + -1 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (-8 + 0 * T) * Math.sin(2 * D + 0 * M + 1 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (7 + 0 * T) * Math.sin(0 * D + 1 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-7 + 0 * T) * Math.sin(-2 * D + 1 * M + 1 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (-7 + 0 * T) * Math.sin(0 * D + -1 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-7 + 0 * T) * Math.sin(2 * D + 0 * M + 0 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (6 + 0 * T) * Math.sin(2 * D + 0 * M + 1 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (6 + 0 * T) * Math.sin(-2 * D + 0 * M + 2 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (6 + 0 * T) * Math.sin(-2 * D + 0 * M + 1 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (-6 + 0 * T) * Math.sin(2 * D + 0 * M + -2 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (-6 + 0 * T) * Math.sin(2 * D + 0 * M + 0 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (5 + 0 * T) * Math.sin(0 * D + -1 * M + 1 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (-5 + 0 * T) * Math.sin(-2 * D + -1 * M + 0 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (-5 + 0 * T) * Math.sin(-2 * D + 0 * M + 0 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (-5 + 0 * T) * Math.sin(0 * D + 0 * M + 2 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (4 + 0 * T) * Math.sin(-2 * D + 0 * M + 2 *  M_ + 0 * F + 1 * Omg);;
    DltPsi += (4 + 0 * T) * Math.sin(-2 * D + 1 * M + 0 *  M_ + 2 * F + 1 * Omg);;
    DltPsi += (4 + 0 * T) * Math.sin(0 * D + 0 * M + 1 *  M_ + -2 * F + 0 * Omg);;
    DltPsi += (-4 + 0 * T) * Math.sin(-1 * D + 0 * M + 1 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (-4 + 0 * T) * Math.sin(-2 * D + 1 * M + 0 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (-4 + 0 * T) * Math.sin(1 * D + 0 * M + 0 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (3 + 0 * T) * Math.sin(0 * D + 0 * M + 1 *  M_ + 2 * F + 0 * Omg);;
    DltPsi += (-3 + 0 * T) * Math.sin(0 * D + 0 * M + -2 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-3 + 0 * T) * Math.sin(-1 * D + -1 * M + 1 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (-3 + 0 * T) * Math.sin(0 * D + 1 * M + 1 *  M_ + 0 * F + 0 * Omg);;
    DltPsi += (-3 + 0 * T) * Math.sin(0 * D + -1 * M + 1 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-3 + 0 * T) * Math.sin(2 * D + -1 * M + -1 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-3 + 0 * T) * Math.sin(0 * D + 0 * M + 3 *  M_ + 2 * F + 2 * Omg);;
    DltPsi += (-3 + 0 * T) * Math.sin(2 * D + -1 * M + 0 *  M_ + 2 * F + 2 * Omg);;
    DltPsi /= 36000000;
  return DltPsi;
}
//
function NutationInObliquity(JD) {
  let T = (JD - 2451545) / 36525;
  let D = 297.85036 + 445267.11148 * T - 0.0019142 * Math.pow(T, 2) + Math.pow(T, 3) / 189474;
  let M = 357.52772 + 35999.05034 * T - 0.0001603 * Math.pow(T, 2) - Math.pow(T, 3) / 300000;
  let M_ = 134.96298 + 477198.867398 * T + 0.0086972 * Math.pow(T, 2) + T * 3 / 56250;
  let F = 93.27191 + 483202.017538 * T - 0.0036825 * Math.pow(T, 2) + Math.pow(T, 3) / 327270;
  let Omg = 125.04452 - 1934.136261 * T + 0.0020708 * Math.pow(T, 2) + Math.pow(T, 3) / 450000;
    D = degToRad(ModFDiv(D, 360));
    M = degToRad(ModFDiv(M, 360));
    M_ = degToRad(ModFDiv( M_, 360));
    F = degToRad(ModFDiv(F, 360));
    Omg = degToRad(ModFDiv(Omg, 360));

     let   DltEps = 0;
    DltEps += (92025 + 8.9 * T) * Math.cos(0 * D + 0 * M + 0 *  M_ + 0 * F + 1 * Omg);
    DltEps += (5736 + -3.1 * T) * Math.cos(-2 * D + 0 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps += (977 + -0.5 * T) * Math.cos(0 * D + 0 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps += (-895 + 0.5 * T) * Math.cos(0 * D + 0 * M + 0 *  M_ + 0 * F + 2 * Omg);
    DltEps += (54 + -0.1 * T) * Math.cos(0 * D + 1 * M + 0 *  M_ + 0 * F + 0 * Omg);
    DltEps += (-7 + 0 * T) * Math.cos(0 * D + 0 * M + 1 *  M_ + 0 * F + 0 * Omg);
    DltEps += (224 + -0.6 * T) * Math.cos(-2 * D + 1 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps += (200 + 0 * T) * Math.cos(0 * D + 0 * M + 0 *  M_ + 2 * F + 1 * Omg);
    DltEps += (129 + -0.1 * T) * Math.cos(0 * D + 0 * M + 1 *  M_ + 2 * F + 2 * Omg);
    DltEps += (-95 + 0.3 * T) * Math.cos(-2 * D + -1 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-2 * D + 0 * M + 1 *  M_ + 0 * F + 0 * Omg);
    DltEps += (-70 + 0 * T) * Math.cos(-2 * D + 0 * M + 0 *  M_ + 2 * F + 1 * Omg);
    DltEps += (-53 + 0 * T) * Math.cos(0 * D + 0 * M + -1 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(2 * D + 0 * M + 0 *  M_ + 0 * F + 0 * Omg);
    DltEps += (-33 + 0 * T) * Math.cos(0 * D + 0 * M + 1 *  M_ + 0 * F + 1 * Omg);
    DltEps += (26 + 0 * T) * Math.cos(2 * D + 0 * M + -1 *  M_ + 2 * F + 2 * Omg);
    DltEps += (32 + 0 * T) * Math.cos(0 * D + 0 * M + -1 *  M_ + 0 * F + 1 * Omg);
    DltEps += (27 + 0 * T) * Math.cos(0 * D + 0 * M + 1 *  M_ + 2 * F + 1 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-2 * D + 0 * M + 2 *  M_ + 0 * F + 0 * Omg);
    DltEps += (-24 + 0 * T) * Math.cos(0 * D + 0 * M + -2 *  M_ + 2 * F + 1 * Omg);
    DltEps += (16 + 0 * T) * Math.cos(2 * D + 0 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps += (13 + 0 * T) * Math.cos(0 * D + 0 * M + 2 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 0 * M + 2 *  M_ + 0 * F + 0 * Omg);
    DltEps += (-12 + 0 * T) * Math.cos(-2 * D + 0 * M + 1 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 0 * M + 0 *  M_ + 2 * F + 0 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-2 * D + 0 * M + 0 *  M_ + 2 * F + 0 * Omg);
    DltEps += (-10 + 0 * T) * Math.cos(0 * D + 0 * M + -1 *  M_ + 2 * F + 1 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 2 * M + 0 *  M_ + 0 * F + 0 * Omg);
    DltEps += (-8 + 0 * T) * Math.cos(2 * D + 0 * M + -1 *  M_ + 0 * F + 1 * Omg);
    DltEps += (7 + 0 * T) * Math.cos(-2 * D + 2 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps += (9 + 0 * T) * Math.cos(0 * D + 1 * M + 0 *  M_ + 0 * F + 1 * Omg);
    DltEps += (7 + 0 * T) * Math.cos(-2 * D + 0 * M + 1 *  M_ + 0 * F + 1 * Omg);
    DltEps += (6 + 0 * T) * Math.cos(0 * D + -1 * M + 0 *  M_ + 0 * F + 1 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 0 * M + 2 *  M_ + -2 * F + 0 * Omg);
    DltEps += (5 + 0 * T) * Math.cos(2 * D + 0 * M + -1 *  M_ + 2 * F + 1 * Omg);
    DltEps += (3 + 0 * T) * Math.cos(2 * D + 0 * M + 1 *  M_ + 2 * F + 2 * Omg);
    DltEps += (-3 + 0 * T) * Math.cos(0 * D + 1 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-2 * D + 1 * M + 1 *  M_ + 0 * F + 0 * Omg);
    DltEps += (3 + 0 * T) * Math.cos(0 * D + -1 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps += (3 + 0 * T) * Math.cos(2 * D + 0 * M + 0 *  M_ + 2 * F + 1 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(2 * D + 0 * M + 1 *  M_ + 0 * F + 0 * Omg);
    DltEps += (-3 + 0 * T) * Math.cos(-2 * D + 0 * M + 2 *  M_ + 2 * F + 2 * Omg);
    DltEps += (-3 + 0 * T) * Math.cos(-2 * D + 0 * M + 1 *  M_ + 2 * F + 1 * Omg);
    DltEps += (3 + 0 * T) * Math.cos(2 * D + 0 * M + -2 *  M_ + 0 * F + 1 * Omg);
    DltEps += (3 + 0 * T) * Math.cos(2 * D + 0 * M + 0 *  M_ + 0 * F + 1 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + -1 * M + 1 *  M_ + 0 * F + 0 * Omg);
    DltEps += (3 + 0 * T) * Math.cos(-2 * D + -1 * M + 0 *  M_ + 2 * F + 1 * Omg);
    DltEps += (3 + 0 * T) * Math.cos(-2 * D + 0 * M + 0 *  M_ + 0 * F + 1 * Omg);
    DltEps += (3 + 0 * T) * Math.cos(0 * D + 0 * M + 2 *  M_ + 2 * F + 1 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-2 * D + 0 * M + 2 *  M_ + 0 * F + 1 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-2 * D + 1 * M + 0 *  M_ + 2 * F + 1 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 0 * M + 1 *  M_ + -2 * F + 0 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-1 * D + 0 * M + 1 *  M_ + 0 * F + 0 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-2 * D + 1 * M + 0 *  M_ + 0 * F + 0 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(1 * D + 0 * M + 0 *  M_ + 0 * F + 0 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 0 * M + 1 *  M_ + 2 * F + 0 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 0 * M + -2 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(-1 * D + -1 * M + 1 *  M_ + 0 * F + 0 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 1 * M + 1 *  M_ + 0 * F + 0 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + -1 * M + 1 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(2 * D + -1 * M + -1 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(0 * D + 0 * M + 3 *  M_ + 2 * F + 2 * Omg);
    DltEps += (0 + 0 * T) * Math.cos(2 * D + -1 * M + 0 *  M_ + 2 * F + 2 * Omg);
    DltEps /= 36000000
    return DltEps;
}
//
function MeanObliquityOfEcliptic(JD) {
  let T = (JD - 2451545) / 36525;
  let U = T / 100;
  let Eps0 = (23 + 26 / 60 + 21.448 / 3600) + (-4680.93 * U
                                            - 1.55 * Math.pow(U, 2)
                                            + 1999.25 * Math.pow(U, 3)
                                            - 51.38 * Math.pow(U, 4)
                                            - 249.67 * Math.pow(U, 5)
                                            - 39.05 * Math.pow(U, 6)
                                            + 7.12 * Math.pow(U, 7)
                                            + 27.87 * Math.pow(U, 8)
                                            + 5.79 * Math.pow(U, 9)
                                            + 2.45 * Math.pow(U, 10)) / 3600;

  return Eps0;
}

//
function ObliquityOfEcliptic(JD) {
  var Eps0 = MeanObliquityOfEcliptic(JD);
  var DltEps = NutationInObliquity(JD);
  var Eps = Eps0 + DltEps;
  return Eps;
}

function EarthHeliocentricLongitude(JD) {
  let Tau = (JD - 2451545) / 365250;
  let L0 = 0;
  L0 += 175347046 * Math.cos(0 + 0 * Tau);
  L0 += 3341656 * Math.cos(4.6692568 + 6283.07585 * Tau);
  L0 += 34894 * Math.cos(4.6261 + 12566.1517 * Tau);
  L0 += 3497 * Math.cos(2.7441 + 5753.3849 * Tau);
  L0 += 3418 * Math.cos(2.8289 + 3.5231 * Tau);
  L0 += 3136 * Math.cos(3.6277 + 77713.7715 * Tau);
  L0 += 2676 * Math.cos(4.4181 + 7860.4194 * Tau);
  L0 += 2343 * Math.cos(6.1352 + 3930.2097 * Tau);
  L0 += 1324 * Math.cos(0.7425 + 11506.7698 * Tau);
  L0 += 1273 * Math.cos(2.0371 + 529.691 * Tau);
  L0 += 1199 * Math.cos(1.1096 + 1577.3435 * Tau);
  L0 += 990 * Math.cos(5.233 + 5884.927 * Tau);
  L0 += 902 * Math.cos(2.045 + 26.298 * Tau);
  L0 += 857 * Math.cos(3.508 + 398.149 * Tau);
  L0 += 780 * Math.cos(1.179 + 5223.694 * Tau);
  L0 += 753 * Math.cos(2.533 + 5507.553 * Tau);
    L0 += 505 * Math.cos(4.583 + 18849.228 * Tau);
    L0 += 492 * Math.cos(4.205 + 775.523 * Tau);
    L0 += 357 * Math.cos(2.92 + 0.067 * Tau);
    L0 += 317 * Math.cos(5.849 + 11790.629 * Tau);
    L0 += 284 * Math.cos(1.899 + 796.298 * Tau);
    L0 += 271 * Math.cos(0.315 + 10977.079 * Tau);
    L0 += 243 * Math.cos(0.345 + 5486.778 * Tau);
    L0 += 206 * Math.cos(4.806 + 2544.314 * Tau);
    L0 += 205 * Math.cos(1.869 + 5573.143 * Tau);
    L0 += 202 * Math.cos(2.458 + 6069.777 * Tau);
    L0 += 156 * Math.cos(0.833 + 213.299 * Tau);
    L0 += 132 * Math.cos(3.411 + 2942.463 * Tau);
    L0 += 126 * Math.cos(1.083 + 20.775 * Tau);
    L0 += 115 * Math.cos(0.645 + 0.98 * Tau);
    L0 += 103 * Math.cos(0.636 + 4694.003 * Tau);
    L0 += 102 * Math.cos(0.976 + 15720.839 * Tau);
    L0 += 102 * Math.cos(4.267 + 7.114 * Tau);
    L0 += 99 * Math.cos(6.21 + 2146.17 * Tau);
    L0 += 98 * Math.cos(0.68 + 155.42 * Tau);
    L0 += 86 * Math.cos(5.98 + 161000.69 * Tau);
    L0 += 85 * Math.cos(1.3 + 6275.96 * Tau);
    L0 += 85 * Math.cos(3.67 + 71430.7 * Tau);
    L0 += 80 * Math.cos(1.81 + 17260.15 * Tau);
    L0 += 79 * Math.cos(3.04 + 12036.46 * Tau);
    L0 += 75 * Math.cos(1.76 + 5088.63 * Tau);
    L0 += 74 * Math.cos(3.5 + 3154.69 * Tau);
    L0 += 74 * Math.cos(4.68 + 801.82 * Tau);
    L0 += 70 * Math.cos(0.83 + 9437.76 * Tau);
    L0 += 62 * Math.cos(3.98 + 8827.39 * Tau);
    L0 += 61 * Math.cos(1.82 + 7084.9 * Tau);
    L0 += 57 * Math.cos(2.78 + 6286.6 * Tau);
    L0 += 56 * Math.cos(4.39 + 14143.5 * Tau);
    L0 += 56 * Math.cos(3.47 + 6279.55 * Tau);
    L0 += 52 * Math.cos(0.19 + 12139.55 * Tau);
    L0 += 52 * Math.cos(1.33 + 1748.02 * Tau);
    L0 += 51 * Math.cos(0.28 + 5856.48 * Tau);
    L0 += 49 * Math.cos(0.49 + 1194.45 * Tau);
    L0 += 41 * Math.cos(5.37 + 8429.24 * Tau);
    L0 += 41 * Math.cos(2.4 + 19651.05 * Tau);
    L0 += 39 * Math.cos(6.17 + 10447.39 * Tau);
    L0 += 37 * Math.cos(6.04 + 10213.29 * Tau);
    L0 += 37 * Math.cos(2.57 + 1059.38 * Tau);
    L0 += 36 * Math.cos(1.71 + 2352.87 * Tau);
    L0 += 36 * Math.cos(1.78 + 6812.77 * Tau);
    L0 += 33 * Math.cos(0.59 + 17789.85 * Tau);
    L0 += 30 * Math.cos(0.44 + 83996.85 * Tau);
    L0 += 30 * Math.cos(2.74 + 1349.87 * Tau);
    L0 += 25 * Math.cos(3.16 + 4690.48 * Tau);
    //'**
    let L1 = 0;
    L1 += 628331966747 * Math.cos(0 + 0 * Tau);
    L1 += 206059 * Math.cos(2.678235 + 6283.07585 * Tau);
    L1 += 4303 * Math.cos(2.6351 + 12566.1517 * Tau);
    L1 += 425 * Math.cos(1.59 + 3.523 * Tau);
    L1 += 119 * Math.cos(5.796 + 26.298 * Tau);
    L1 += 109 * Math.cos(2.966 + 1577.344 * Tau);
    L1 += 93 * Math.cos(2.59 + 18849.23 * Tau);
    L1 += 72 * Math.cos(1.14 + 529.69 * Tau);
    L1 += 68 * Math.cos(1.87 + 398.15 * Tau);
    L1 += 67 * Math.cos(4.41 + 5507.55 * Tau);
    L1 += 59 * Math.cos(2.89 + 5223.69 * Tau);
    L1 += 56 * Math.cos(2.17 + 155.42 * Tau);
    L1 += 45 * Math.cos(0.4 + 796.3 * Tau);
    L1 += 36 * Math.cos(0.47 + 775.52 * Tau);
    L1 += 29 * Math.cos(2.65 + 7.11 * Tau);
    L1 += 21 * Math.cos(5.34 + 0.98 * Tau);
    L1 += 19 * Math.cos(1.85 + 5486.78 * Tau);
    L1 += 19 * Math.cos(4.97 + 213.3 * Tau);
    L1 += 17 * Math.cos(2.99 + 6275.96 * Tau);
    L1 += 16 * Math.cos(0.03 + 2544.31 * Tau);
    L1 += 16 * Math.cos(1.43 + 2146.17 * Tau);
    L1 += 15 * Math.cos(1.21 + 10977.08 * Tau);
    L1 += 12 * Math.cos(2.83 + 1748.02 * Tau);
    L1 += 12 * Math.cos(3.26 + 5088.63 * Tau);
    L1 += 12 * Math.cos(5.27 + 1194.45 * Tau);
    L1 += 12 * Math.cos(2.08 + 4694 * Tau);
    L1 += 11 * Math.cos(0.77 + 553.57 * Tau);
    L1 += 10 * Math.cos(1.3 + 6286.6 * Tau);
    L1 += 10 * Math.cos(4.24 + 1349.87 * Tau);
    L1 += 9 * Math.cos(2.7 + 242.73 * Tau);
    L1 += 9 * Math.cos(5.64 + 951.72 * Tau);
    L1 += 8 * Math.cos(5.3 + 2352.87 * Tau);
    L1 += 6 * Math.cos(2.65 + 9437.76 * Tau);
    L1 += 6 * Math.cos(4.67 + 4690.48 * Tau);
    //'**
    let L2 = 0;
    L2 += 52919 * Math.cos(0 + 0 * Tau);
    L2 += 8720 * Math.cos(1.0721 + 6283.0758 * Tau);
    L2 += 309 * Math.cos(0.867 + 12566.152 * Tau);
    L2 += 27 * Math.cos(0.05 + 3.52 * Tau);
    L2 += 16 * Math.cos(5.19 + 26.3 * Tau);
    L2 += 16 * Math.cos(3.68 + 155.42 * Tau);
    L2 += 10 * Math.cos(0.76 + 18849.23 * Tau);
    L2 += 9 * Math.cos(2.06 + 77713.77 * Tau);
    L2 += 7 * Math.cos(0.83 + 775.52 * Tau);
    L2 += 5 * Math.cos(4.66 + 1577.34 * Tau);
    L2 += 4 * Math.cos(1.03 + 7.11 * Tau);
    L2 += 4 * Math.cos(3.44 + 5573.14 * Tau);
    L2 += 3 * Math.cos(5.14 + 796.3 * Tau);
    L2 += 3 * Math.cos(6.05 + 5507.55 * Tau);
    L2 += 3 * Math.cos(1.19 + 242.73 * Tau);
    L2 += 3 * Math.cos(6.12 + 529.69 * Tau);
    L2 += 3 * Math.cos(0.31 + 398.15 * Tau);
    L2 += 3 * Math.cos(2.28 + 553.57 * Tau);
    L2 += 2 * Math.cos(4.38 + 5223.69 * Tau);
    L2 += 2 * Math.cos(3.75 + 0.98 * Tau);
    //'**
    let L3 = 0;
    L3 += 289 * Math.cos(5.844 + 6283.076 * Tau);
    L3 += 35 * Math.cos(0 + 0 * Tau);
    L3 += 17 * Math.cos(5.49 + 12566.15 * Tau);
    L3 += 3 * Math.cos(5.2 + 155.42 * Tau);
    L3 += 1 * Math.cos(4.72 + 3.52 * Tau);
    L3 += 1 * Math.cos(5.3 + 18849.23 * Tau);
    L3 += 1 * Math.cos(5.97 + 242.73 * Tau);
    //'**
    L4 = 0;
    L4 += 114 * Math.cos(3.142 + 0 * Tau);
    L4 += 8 * Math.cos(4.13 + 6283.08 * Tau);
    L4 += 1 * Math.cos(3.84 + 12566.15 * Tau);
   // '**
    let L5 = 0;

    L5 += 1 * Math.cos(3.14 + 0 * Tau);
    let l = (L0 + L1 * Tau + L2 * Math.pow(Tau, 2) + L3 * Math.pow(Tau, 3) + L4 * Math.pow(Tau, 4) + L5 * Math.pow(Tau, 5)) / 100000000;
  l = (180 / Math.PI) * l;
  l = ModFDiv(l, 360);
  return l;
}
//
function EarthHeliocentricLatitude(JD) {
  const Tau = (JD - 2451545) / 365250;
  let B0 = 0;
  B0 += 280 * Math.cos(3.199 + 84334.662 * Tau);
  B0 += 102 * Math.cos(5.422 + 5507.553 * Tau);
  B0 += 80 * Math.cos(3.88 + 5223.69 * Tau);
  B0 += 44 * Math.cos(3.7 + 2352.87 * Tau);
  B0 += 32 * Math.cos(4 + 1577.34 * Tau);

  let B1 = 0;
  B1 += 9 * Math.cos(3.9 + 5507.55 * Tau);
  B1 += 6 * Math.cos(1.73 + 5223.69 * Tau);

  let b = (B0 + B1 * Tau) / 100000000;
  b = b * (180 / Math.PI);

  return b;
}
//
function EarthRadiusVector(JD) {
  let Tau = (JD - 2451545) / 365250;
  let R0 = 0;
  R0 += 100013989 * Math.cos(0 + 0 * Tau);
  R0 += 1670700 * Math.cos(3.0984635 + 6283.07585 * Tau);
  R0 += 13956 * Math.cos(3.05525 + 12566.1517 * Tau);
  R0 += 3084 * Math.cos(5.1985 + 77713.7715 * Tau);
  R0 += 1628 * Math.cos(1.1739 + 5753.3849 * Tau);
  R0 += 1576 * Math.cos(2.8469 + 7860.4194 * Tau);
  R0 += 925 * Math.cos(5.453 + 11506.77 * Tau);
  R0 += 542 * Math.cos(4.564 + 3930.21 * Tau);
  R0 += 472 * Math.cos(3.661 + 5884.927 * Tau);
  R0 += 346 * Math.cos(0.964 + 5507.553 * Tau);
  R0 += 329 * Math.cos(5.9 + 5223.694 * Tau);
  R0 += 307 * Math.cos(0.299 + 5573.143 * Tau);
  R0 += 243 * Math.cos(4.273 + 11790.629 * Tau);
  R0 += 212 * Math.cos(5.847 + 1577.344 * Tau);
  R0 += 186 * Math.cos(5.022 + 10977.079 * Tau);
  R0 += 175 * Math.cos(3.012 + 18849.228 * Tau);
  R0 += 110 * Math.cos(5.055 + 5486.778 * Tau);
  R0 += 98 * Math.cos(0.89 + 6069.78 * Tau);
  R0 += 86 * Math.cos(5.69 + 15720.84 * Tau);
  R0 += 86 * Math.cos(1.27 + 161000.69 * Tau);
  R0 += 65 * Math.cos(0.27 + 17260.15 * Tau);
  R0 += 63 * Math.cos(0.92 + 529.69 * Tau);
  R0 += 57 * Math.cos(2.01 + 83996.85 * Tau);
  R0 += 56 * Math.cos(5.24 + 71430.7 * Tau);
  R0 += 49 * Math.cos(3.25 + 2544.31 * Tau);
  R0 += 47 * Math.cos(2.58 + 775.52 * Tau);
  R0 += 45 * Math.cos(5.54 + 9437.76 * Tau);
  R0 += 43 * Math.cos(6.01 + 6275.96 * Tau);
  R0 += 39 * Math.cos(5.36 + 4694 * Tau);
  R0 += 38 * Math.cos(2.39 + 8827.39 * Tau);
  R0 += 37 * Math.cos(0.83 + 19651.05 * Tau);
    R0 += 37 * Math.cos(4.9 + 12139.55 * Tau);
    R0 += 36 * Math.cos(1.67 + 12036.46 * Tau);
    R0 += 35 * Math.cos(1.84 + 2942.46 * Tau);
    R0 += 33 * Math.cos(0.24 + 7084.9 * Tau);
    R0 += 32 * Math.cos(0.18 + 5088.63 * Tau);
    R0 += 32 * Math.cos(1.78 + 398.15 * Tau);
    R0 += 28 * Math.cos(1.21 + 6286.6 * Tau);
    R0 += 28 * Math.cos(1.9 + 6279.55 * Tau);
    R0 += 26 * Math.cos(4.59 + 10447.39 * Tau);
   // '**
    let R1 = 0;
    R1 += 103019 * Math.cos(1.10749 + 6283.07585 * Tau);
    R1 += 1721 * Math.cos(1.0644 + 12566.1517 * Tau);
    R1 += 702 * Math.cos(3.142 + 0 * Tau);
    R1 += 32 * Math.cos(1.02 + 18849.23 * Tau);
    R1 += 31 * Math.cos(2.84 + 5507.55 * Tau);
    R1 += 25 * Math.cos(1.32 + 5223.69 * Tau);
    R1 += 18 * Math.cos(1.42 + 1577.34 * Tau);
    R1 += 10 * Math.cos(5.91 + 10977.08 * Tau);
    R1 += 9 * Math.cos(1.42 + 6275.96 * Tau);
    R1 += 9 * Math.cos(0.27 + 5486.78 * Tau);
    //'**
    let R2 = 0;
    R2 += 4359 * Math.cos(5.7846 + 6283.0758 * Tau);
    R2 += 124 * Math.cos(5.579 + 12566.152 * Tau);
    R2 += 12 * Math.cos(3.14 + 0 * Tau);
    R2 += 9 * Math.cos(3.63 + 77713.77 * Tau);
    R2 += 6 * Math.cos(1.87 + 5573.14 * Tau);
    R2 += 3 * Math.cos(5.47 + 18849.23 * Tau);
   // '**

  let R3 = 145 * Math.cos(4.273 + 6283.076 * Tau); + 7 * Math.cos(3.92 + 12566.15 * Tau);
  let R4 = 4 * Math.cos(2.56 + 6283.08 * Tau);
  let R = (R0 + R1 * Tau + R2 * Math.pow(Tau, 2) + R3 * Math.pow(Tau, 3) + R4 * Math.pow(Tau, 4)) / 100000000;
  return R;
}
//
function SunGeocentricLongitude(JD, OptResult = "") {
let l;
let b;
let Theta;
let Beta;
let T;
let LambdaPrime;
let DeltaTheta;
let ThetaFK5;
let DeltaPsi;
let Abberration;
let Lambda;
let Result;

l = EarthHeliocentricLongitude(JD);
b = EarthHeliocentricLatitude(JD);
Theta = l + 180;
Theta = Theta % 360;
Beta = -b;

T = (JD - 2451545) / 36525;
LambdaPrime = Theta - 1.397 * T - 0.00031 * Math.pow(T, 2);
DeltaTheta = (-0.09033 + 0.03916 * (Math.cos(LambdaPrime * (Math.PI / 180)) + Math.sin(LambdaPrime * (Math.PI / 180))) * Math.tan(Beta * (Math.PI / 180))) / 3600;
ThetaFK5 = Theta + DeltaTheta;

DeltaPsi = NutationInLongitude(JD);
Abberration = (-20.4898 / EarthRadiusVector(JD)) / 3600;
Lambda = ThetaFK5 + DeltaPsi + Abberration;
Lambda = Lambda % 360;

switch (OptResult.toUpperCase().replace(/ /g, "")) {
case "GEOMETRICVSOP87":
case "TRUEVSOP87":
Result = Theta;
break;
case "GEOMETRICFK5SYSTEM":
case "TRUEFK5SYSTEM":
Result = ThetaFK5;
break;
case "APPARENT":
Result = Lambda;
break;
default:
Result = Lambda;
}
return Result;
}
//
function SunGeocentricLatitude(JD, OptResult = "") {
  let l;
  let b;
  let Theta;
  let Beta;
  let T;
  let Lambda;
  let DeltaBeta;
  let BetaFK5;
  let Result;

  l = EarthHeliocentricLongitude(JD);
  b = EarthHeliocentricLatitude(JD);
  Theta = l + 180;
  Theta = ModFDiv(Theta , 360) ;
  Beta = -b;
  T = (JD - 2451545) / 36525;
  Lambda = Theta - 1.397 * T - 0.00031 * Math.pow(T, 2);
  DeltaBeta = (0.03916 * (Math.cos(degToRad(Lambda)) - Math.sin(degToRad(Lambda )))) / 3600;
  BetaFK5 = Beta + DeltaBeta;
  switch (OptResult.toUpperCase().replace(/ /g, "")) {
    case "GEOMETRICVSOP87":
    case "TRUEVSOP87":
      Result = Beta;
      break;
    case "GEOMETRICFK5SYSTEM":
    case "TRUEFK5SYSTEM":
      Result = BetaFK5;
      break;
    case "APPARENT":
      Result = BetaFK5;
      break;
    default:
      Result = BetaFK5;
  }

  return BetaFK5;
}

//
function SunGeocentricDistance(JD, OptResult = "") {
let R;
let Result;
R = EarthRadiusVector(JD);
switch (OptResult.toUpperCase().replace(/ /g, '')) {
case "AU":
Result = R;
break;
case "KM":
Result = R * 149597870.7;
break;
case "ER":
Result = R * 149597870.7 / 6371;
break;
default:
Result = R;
}
return Result;
}
//

function SunApparentRightAscension(JD) {
  let Lambda;
  let Beta;
  let Epsilon;
  let Alpha;
  
  Lambda = SunGeocentricLongitude(JD, "Apparent");
  Beta = SunGeocentricLatitude(JD, "Apparent");
  Epsilon = ObliquityOfEcliptic(JD);
  Alpha = radToDeg(Math.atan2(Math.sin(degToRad(Lambda)) * Math.cos(degToRad(Epsilon)) - Math.tan(degToRad(Beta)) * Math.sin(degToRad(Epsilon)), Math.cos(degToRad(Lambda))));
  Alpha = ModFDiv(Alpha , 360);
  
  return Alpha;
}

//
function SunApparentDeclination(JD) {
  let Lambda = SunGeocentricLongitude(JD, "Apparent");
  let Beta = SunGeocentricLatitude(JD, "Apparent");
  let Epsilon = ObliquityOfEcliptic(JD);
  let Delta = radToDeg(Math.asin(Math.sin(degToRad(Beta)) * Math.cos(degToRad(Epsilon)) + Math.cos(degToRad(Beta)) * Math.sin(degToRad(Epsilon)) * Math.sin(degToRad(Lambda))));
  return Delta;
}
//
function SunEquatorialHorizontalParallax(JD) {
// Deklarasi Variabel dan Tipe Variabel
let R = 0;
let Pi = 0;

// Proses Perhitungan
R = SunGeocentricDistance(JD, "AU");
Pi = (Math.asin(Math.sin(degToRad(8.794 / 3600)) / R) * 180) / Math.PI;

// Hasil Perhitungan
return Pi;
}
//
function SunAngularSemiDiameter(JD) {
  let R = SunGeocentricDistance(JD, "AU");
  let s0 = 15 + 59.63 / 60;
  let s = s0 / R;
  return s / 60;
}
//
function EquationOfTime(JD) {
  let Tau = (JD - 2451545) / 365250;
  let Alpha = SunApparentRightAscension(JD);
  let DeltaPsi = NutationInLongitude(JD);
  let Epsilon = ObliquityOfEcliptic(JD);
  let L0 = 280.4664567 + 360007.6982779 * Tau + 0.03032028 * Tau * Tau + Tau * Tau * Tau / 49931 - Tau * Tau * Tau * Tau / 15300 - Tau * Tau * Tau * Tau * Tau / 2000000;
  L0 = ModFDiv(L0 , 360) ;
  let E = L0 - 0.0057183 - Alpha + DeltaPsi * Math.cos(Epsilon * Math.PI / 180);
  if (Math.abs(E) * 4 < 20) {
    E = E / 15;
  } else if (Math.abs(E) * 4 >= 20 && E > 0) {
    E = E / 15 - 24;
  } else if (Math.abs(E) * 4 >= 20 && E < 0) {
    E = E / 15 + 24;
  } else {
    E = E / 15;
  }
  return E;
}

function Absol(x){
return Math.abs(x);
}


  
// data bulan

function MoonGeocentricLongitude(JD, OptResult = "") {
  // Declare variables and their types
  let T = (JD - 2451545) / 36525;
  let L = 218.3164477 + 481267.88123421 * T - 0.0015786 * T ** 2 + T ** 3 / 538841 - T ** 4 / 65194000;
  let D = 297.8501921 + 445267.1114034 * T - 0.0018819 * T ** 2 + T ** 3 / 545868 - T ** 4 / 113065000;
  let M = 357.5291092 + 35999.0502909 * T - 0.0001536 * T ** 2 + T ** 3 / 24490000;
  let M_ = 134.9633964 + 477198.8675055 * T + 0.0087414 * T ** 2 + T ** 3 / 69699 - T ** 4 / 14712000;
  let F = 93.272095 + 483202.0175233 * T - 0.0036539 * T ** 2 - T ** 3 / 3526000 + T ** 4 / 863310000;
  let A1 = 119.75 + 131.849 * T;
  let A2 = 53.09 + 479264.29 * T;
  let A3 = 313.45 + 481266.484 * T;
  let E = 1 - 0.002516 * T - 0.0000074 * T ** 2;
  L = degToRad(ModFDiv(L, 360));
  D = degToRad(ModFDiv(D, 360));
  M = degToRad(ModFDiv(M, 360));
  M_ = degToRad(ModFDiv(M_, 360));
  F = degToRad(ModFDiv(F, 360));
  A1 = degToRad(ModFDiv(A1, 360));
  A2 = degToRad(ModFDiv(A2, 360));
  A3 = degToRad(ModFDiv(A3, 360));
    let lM = 0;
    lM += 6288774 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 1 * M_ + 0 * F);
    lM += 1274027 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -1 * M_ + 0 * F);
    lM += 658314 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 0 * M_ + 0 * F);
    lM += 213618 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 2 * M_ + 0 * F);
    lM += -185116 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + 0 * M_ + 0 * F);
    lM += -114332 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 0 * M_ + 2 * F);
    lM += 58793 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -2 * M_ + 0 * F);
    lM += 57066 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + -1 * M_ + 0 * F);
    lM += 53322 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 1 * M_ + 0 * F);
    lM += 45758 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + 0 * M_ + 0 * F);
    lM += -40923 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + -1 * M_ + 0 * F);
    lM += -34720 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + 0 * M_ + 0 * F);
    lM += -30383 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + 1 * M_ + 0 * F);
    lM += 15327 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 0 * M_ + -2 * F);
    lM += -12528 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 1 * M_ + 2 * F);
    lM += 10980 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 1 * M_ + -2 * F);
    lM += 10675 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + -1 * M_ + 0 * F);
    lM += 10034 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 3 * M_ + 0 * F);
    lM += 8548 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + -2 * M_ + 0 * F);
    lM += -7888 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + -1 * M_ + 0 * F);
    lM += -6766 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + 0 * M_ + 0 * F);
    lM += -5163 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + -1 * M_ + 0 * F);
    lM += 4987 * (E ** Math.abs(1)) * Math.sin(1 * D + 1 * M + 0 * M_ + 0 * F);
    lM += 4036 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + 1 * M_ + 0 * F);
    lM += 3994 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 2 * M_ + 0 * F);
    lM += 3861 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + 0 * M_ + 0 * F);
    lM += 3665 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -3 * M_ + 0 * F);
    lM += -2689 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + -2 * M_ + 0 * F);
    lM += -2602 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -1 * M_ + 2 * F);
    lM += 2390 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + -2 * M_ + 0 * F);
    lM += -2348 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + 1 * M_ + 0 * F);
    lM += 2236 * (E ** Math.abs(-2)) * Math.sin(2 * D + -2 * M + 0 * M_ + 0 * F);
    lM += -2120 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + 2 * M_ + 0 * F);
    lM += -2069 * (E ** Math.abs(2)) * Math.sin(0 * D + 2 * M + 0 * M_ + 0 * F);
    lM += 2048 * (E ** Math.abs(-2)) * Math.sin(2 * D + -2 * M + -1 * M_ + 0 * F);
    lM += -1773 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 1 * M_ + -2 * F);
    lM += -1595 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 0 * M_ + 2 * F);
    lM += 1215 * (E ** Math.abs(-1)) * Math.sin(4 * D + -1 * M + -1 * M_ + 0 * F);
    lM += -1110 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 2 * M_ + 2 * F);
    lM += -892 * (E ** Math.abs(0)) * Math.sin(3 * D + 0 * M + -1 * M_ + 0 * F);
    lM += -810 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + 1 * M_ + 0 * F);
    lM += 759 * (E ** Math.abs(-1)) * Math.sin(4 * D + -1 * M + -2 * M_ + 0 * F);
    lM += -713 * (E ** Math.abs(2)) * Math.sin(0 * D + 2 * M + -1 * M_ + 0 * F);
    lM += -700 * (E ** Math.abs(2)) * Math.sin(2 * D + 2 * M + -1 * M_ + 0 * F);
    lM += 691 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + -2 * M_ + 0 * F);
    lM += 596 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + 0 * M_ + -2 * F);
    lM += 549 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + 1 * M_ + 0 * F);
    lM += 537 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 4 * M_ + 0 * F);
    lM += 520 * (E ** Math.abs(-1)) * Math.sin(4 * D + -1 * M + 0 * M_ + 0 * F);
    lM += -487 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + -2 * M_ + 0 * F);
    lM += -399 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + 0 * M_ + -2 * F);
    lM += -381 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 2 * M_ + -2 * F);
    lM += 351 * (E ** Math.abs(1)) * Math.sin(1 * D + 1 * M + 1 * M_ + 0 * F);
    lM += -340 * (E ** Math.abs(0)) * Math.sin(3 * D + 0 * M + -2 * M_ + 0 * F);
    lM += 330 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + -3 * M_ + 0 * F);
    lM += 327 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + 2 * M_ + 0 * F);
    lM += -323 * (E ** Math.abs(2)) * Math.sin(0 * D + 2 * M + 1 * M_ + 0 * F);
    lM += 299 * (E ** Math.abs(1)) * Math.sin(1 * D + 1 * M + -1 * M_ + 0 * F);
    lM += 294 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 3 * M_ + 0 * F);
    lM += 0 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -1 * M_ + -2 * F);
    lM += 3958 * Math.sin(A1) + 1962 * Math.sin(L - F) + 318 * Math.sin(A2);
  let lM_True = radToDeg(L) + lM / 1000000;
  lM_True = ModFDiv(lM_True, 360);
  let lM_Appa = lM_True + NutationInLongitude(JD);
  lM_Appa = ModFDiv(lM_Appa, 360);
  let result;
  switch (OptResult.toUpperCase().replace(/ /g, "")) {
    case "":
    case "APPARENT":
      result = lM_Appa;
      break;
    case "GEOMETRIC":
      result = lM_True;
      break;
    default:
      result = lM_Appa;
  }
  return result;

}
//
function MoonGeocentricLatitude(JD, OptResult = "") {
    let T = (JD - 2451545) / 36525;
    let L = 218.3164477 + 481267.88123421 * T - 0.0015786 * T * T + T * T * T / 538841 - T * T * T * T / 65194000;
    let D = 297.8501921 + 445267.1114034 * T - 0.0018819 * T * T + T * T * T / 545868 - T * T * T * T / 113065000;
    let M = 357.5291092 + 35999.0502909 * T - 0.0001536 * T * T + T * T * T / 24490000;
    let M_ = 134.9633964 + 477198.8675055 * T + 0.0087414 * T * T + T * T * T / 69699 - T * T * T * T / 14712000;
    let F = 93.272095 + 483202.0175233 * T - 0.0036539 * T * T - T * T * T / 3526000 + T * T * T * T / 863310000;
    let A1 = 119.75 + 131.849 * T;
    let A2 = 53.09 + 479264.29 * T;
    let A3 = 313.45 + 481266.484 * T;
    let E = 1 - 0.002516 * T - 0.0000074 * T * T;
    L = degToRad(ModFDiv( L , 360));
    D = degToRad(ModFDiv(D , 360));
    M = degToRad(ModFDiv(M , 360));
    M_ = degToRad(ModFDiv(M_ , 360));
    F = degToRad(ModFDiv(F , 360));
    A1 = degToRad(ModFDiv(A1 , 360));
    A2 = degToRad(ModFDiv(A2 , 360));
    A3 = degToRad(ModFDiv(A3 , 360));
    let bM = 0;
    bM += 5128122 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 0 * M_ + 1 * F);
    bM += 280602 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 1 * M_ + 1 * F);
    bM += 277693 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 1 * M_ + -1 * F);
    bM += 173237 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 0 * M_ + -1 * F);
    bM += 55413 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -1 * M_ + 1 * F);
    bM += 46271 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -1 * M_ + -1 * F);
    bM += 32573 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 0 * M_ + 1 * F);
    bM += 17198 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 2 * M_ + 1 * F);
    bM += 9266 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 1 * M_ + -1 * F);
    bM += 8822 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 2 * M_ + -1 * F);
    bM += 8216 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + 0 * M_ + -1 * F);
    bM += 4324 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -2 * M_ + -1 * F);
    bM += 4200 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 1 * M_ + 1 * F);
    bM += -3359 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + 0 * M_ + -1 * F);
    bM += 2463 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + -1 * M_ + 1 * F);
    bM += 2211 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + 0 * M_ + 1 * F);
    bM += 2065 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + -1 * M_ + -1 * F);
    bM += -1870 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + -1 * M_ + -1 * F);
    bM += 1828 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + -1 * M_ + -1 * F);
    bM += -1794 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + 0 * M_ + 1 * F);
    bM += -1749 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 0 * M_ + 3 * F);
    bM += -1565 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + -1 * M_ + 1 * F);
    bM += -1491 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + 0 * M_ + 1 * F);
    bM += -1475 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + 1 * M_ + 1 * F);
    bM += -1410 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + 1 * M_ + -1 * F);
    bM += -1344 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + 0 * M_ + -1 * F);
    bM += -1335 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + 0 * M_ + -1 * F);
    bM += 1107 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 3 * M_ + 1 * F);
    bM += 1021 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + 0 * M_ + -1 * F);
    bM += 833 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + -1 * M_ + 1 * F);
    bM += 777 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 1 * M_ + -3 * F);
    bM += 671 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + -2 * M_ + 1 * F);
    bM += 607 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 0 * M_ + -3 * F);
    bM += 596 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 2 * M_ + -1 * F);
    bM += 491 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + 1 * M_ + -1 * F);
    bM += -451 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -2 * M_ + 1 * F);
    bM += 439 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 3 * M_ + -1 * F);
    bM += 422 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + 2 * M_ + 1 * F);
    bM += 421 * (E ** Math.abs(0)) * Math.sin(2 * D + 0 * M + -3 * M_ + -1 * F);
    bM += -366 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + -1 * M_ + 1 * F);
    bM += -351 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + 0 * M_ + 1 * F);
    bM += 331 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + 0 * M_ + 1 * F);
    bM += 315 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + 1 * M_ + 1 * F);
    bM += 302 * (E ** Math.abs(-2)) * Math.sin(2 * D + -2 * M + 0 * M_ + -1 * F);
    bM += -283 * (E ** Math.abs(0)) * Math.sin(0 * D + 0 * M + 1 * M_ + 3 * F);
    bM += -229 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + 1 * M_ + -1 * F);
    bM += 223 * (E ** Math.abs(1)) * Math.sin(1 * D + 1 * M + 0 * M_ + -1 * F);
    bM += 223 * (E ** Math.abs(1)) * Math.sin(1 * D + 1 * M + 0 * M_ + 1 * F);
    bM += -220 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + -2 * M_ + -1 * F);
    bM += -220 * (E ** Math.abs(1)) * Math.sin(2 * D + 1 * M + -1 * M_ + -1 * F);
    bM += -185 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + 1 * M_ + 1 * F);
    bM += 181 * (E ** Math.abs(-1)) * Math.sin(2 * D + -1 * M + -2 * M_ + -1 * F);
    bM += -177 * (E ** Math.abs(1)) * Math.sin(0 * D + 1 * M + 2 * M_ + 1 * F);
    bM += 176 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + -2 * M_ + -1 * F);
    bM += 166 * (E ** Math.abs(-1)) * Math.sin(4 * D + -1 * M + -1 * M_ + -1 * F);
    bM += -164 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + 1 * M_ + -1 * F);
    bM += 132 * (E ** Math.abs(0)) * Math.sin(4 * D + 0 * M + 1 * M_ + -1 * F);
    bM += -119 * (E ** Math.abs(0)) * Math.sin(1 * D + 0 * M + -1 * M_ + -1 * F);
    bM += 115 * (E ** Math.abs(-1)) * Math.sin(4 * D + -1 * M + 0 * M_ + -1 * F);
    bM += 107 * (E ** Math.abs(-2)) * Math.sin(2 * D + -2 * M + 0 * M_ + 1 * F);
    bM += (-2235 * Math.sin(L) + 382 * Math.sin(A3) + 175 * Math.sin(A1 - F) + 175 * Math.sin(A1 + F) + 127 * Math.sin(L - M_) - 115 * Math.sin(L + M_));
    bM =bM / 1000000;
    let Result;
    switch (OptResult.toUpperCase().replace(/\s/g, "")) {
        case "":
        case "APPARENT":
            Result = bM;
            break;
        case "GEOMETRIC":
            Result = bM;
            break;
        default:
            Result = bM;
    }
    return Result;
}
//
function MoonGeocentricDistance(JD, OptResult = "") {
// Declare Variables and Variable Types
let T = (JD - 2451545) / 36525;
let L = 218.3164477 + 481267.88123421 * T - 0.0015786 * T ** 2 + T ** 3 / 538841 - T ** 4 / 65194000;
let D = 297.8501921 + 445267.1114034 * T - 0.0018819 * T ** 2 + T ** 3 / 545868 - T ** 4 / 113065000;
let M = 357.5291092 + 35999.0502909 * T - 0.0001536 * T ** 2 + T ** 3 / 24490000;
let M_ = 134.9633964 + 477198.8675055 * T + 0.0087414 * T ** 2 + T ** 3 / 69699 - T ** 4 / 14712000;
let F = 93.272095 + 483202.0175233 * T - 0.0036539 * T ** 2 - T ** 3 / 3526000 + T ** 4 / 863310000;
let A1 = 119.75 + 131.849 * T;
let A2 = 53.09 + 479264.29 * T;
let A3 = 313.45 + 481266.484 * T;
let E = 1 - 0.002516 * T - 0.0000074 * T ** 2;
L = degToRad(ModFDiv(L, 360));
D = degToRad(ModFDiv(D, 360));
M = degToRad(ModFDiv(M, 360));
M_ = degToRad(ModFDiv(M_, 360));
F = degToRad(ModFDiv(F, 360));
A1 = degToRad(ModFDiv(A1, 360));
A2 = degToRad(ModFDiv(A2, 360));
A3 = degToRad(ModFDiv(A3, 360));
let rM = 0;
rM += -20905355 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 1 * M_ + 0 * F);
rM += -3699111 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + -1 * M_ + 0 * F);
    rM += -2955968 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + 0 * M_ + 0 * F)
    rM += -569925 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 2 * M_ + 0 * F)
    rM += 48888 * (E ** Math.abs(1)) * Math.cos(0 * D + 1 * M + 0 * M_ + 0 * F)
    rM += -3149 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 0 * M_ + 2 * F)
    rM += 246158 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + -2 * M_ + 0 * F)
    rM += -152138 * (E ** Math.abs(-1)) * Math.cos(2 * D + -1 * M + -1 * M_ + 0 * F)
    rM += -170733 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + 1 * M_ + 0 * F)
    rM += -204586 * (E ** Math.abs(-1)) * Math.cos(2 * D + -1 * M + 0 * M_ + 0 * F)
    rM += -129620 * (E ** Math.abs(1)) * Math.cos(0 * D + 1 * M + -1 * M_ + 0 * F)
    rM += 108743 * (E ** Math.abs(0)) * Math.cos(1 * D + 0 * M + 0 * M_ + 0 * F)
    rM += 104755 * (E ** Math.abs(1)) * Math.cos(0 * D + 1 * M + 1 * M_ + 0 * F)
    rM += 10321 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + 0 * M_ + -2 * F)
    rM += 0 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 1 * M_ + 2 * F)
    rM += 79661 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 1 * M_ + -2 * F)
    rM += -34782 * (E ** Math.abs(0)) * Math.cos(4 * D + 0 * M + -1 * M_ + 0 * F)
    rM += -23210 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 3 * M_ + 0 * F)
    rM += -21636 * (E ** Math.abs(0)) * Math.cos(4 * D + 0 * M + -2 * M_ + 0 * F)
    rM += 24208 * (E ** Math.abs(1)) * Math.cos(2 * D + 1 * M + -1 * M_ + 0 * F)
    rM += 30824 * (E ** Math.abs(1)) * Math.cos(2 * D + 1 * M + 0 * M_ + 0 * F)
    rM += -8379 * (E ** Math.abs(0)) * Math.cos(1 * D + 0 * M + -1 * M_ + 0 * F)
    rM += -16675 * (E ** Math.abs(1)) * Math.cos(1 * D + 1 * M + 0 * M_ + 0 * F)
    rM += -12831 * (E ** Math.abs(-1)) * Math.cos(2 * D + -1 * M + 1 * M_ + 0 * F)
    rM += -10445 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + 2 * M_ + 0 * F)
    rM += -11650 * (E ** Math.abs(0)) * Math.cos(4 * D + 0 * M + 0 * M_ + 0 * F)
    rM += 14403 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + -3 * M_ + 0 * F)
    rM += -7003 * (E ** Math.abs(1)) * Math.cos(0 * D + 1 * M + -2 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + -1 * M_ + 2 * F)
    rM += 10056 * (E ** Math.abs(-1)) * Math.cos(2 * D + -1 * M + -2 * M_ + 0 * F)
    rM += 6322 * (E ** Math.abs(0)) * Math.cos(1 * D + 0 * M + 1 * M_ + 0 * F)
    rM += -9884 * (E ** Math.abs(-2)) * Math.cos(2 * D + -2 * M + 0 * M_ + 0 * F)
    rM += 5751 * (E ** Math.abs(1)) * Math.cos(0 * D + 1 * M + 2 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(2)) * Math.cos(0 * D + 2 * M + 0 * M_ + 0 * F)
    rM += -4950 * (E ** Math.abs(-2)) * Math.cos(2 * D + -2 * M + -1 * M_ + 0 * F)
    rM += 4130 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + 1 * M_ + -2 * F)
    rM += 0 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + 0 * M_ + 2 * F)
    rM += -3958 * (E ** Math.abs(-1)) * Math.cos(4 * D + -1 * M + -1 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 2 * M_ + 2 * F)
    rM += 3258 * (E ** Math.abs(0)) * Math.cos(3 * D + 0 * M + -1 * M_ + 0 * F)
    rM += 2616 * (E ** Math.abs(1)) * Math.cos(2 * D + 1 * M + 1 * M_ + 0 * F)
    rM += -1897 * (E ** Math.abs(-1)) * Math.cos(4 * D + -1 * M + -2 * M_ + 0 * F)
    rM += -2117 * (E ** Math.abs(2)) * Math.cos(0 * D + 2 * M + -1 * M_ + 0 * F)
    rM += 2354 * (E ** Math.abs(2)) * Math.cos(2 * D + 2 * M + -1 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(1)) * Math.cos(2 * D + 1 * M + -2 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(-1)) * Math.cos(2 * D + -1 * M + 0 * M_ + -2 * F)
    rM += -1423 * (E ** Math.abs(0)) * Math.cos(4 * D + 0 * M + 1 * M_ + 0 * F)
    rM += -1117 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 4 * M_ + 0 * F)
    rM += -1571 * (E ** Math.abs(-1)) * Math.cos(4 * D + -1 * M + 0 * M_ + 0 * F)
    rM += -1739 * (E ** Math.abs(0)) * Math.cos(1 * D + 0 * M + -2 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(1)) * Math.cos(2 * D + 1 * M + 0 * M_ + -2 * F)
    rM += -4421 * (E ** Math.abs(0)) * Math.cos(0 * D + 0 * M + 2 * M_ + -2 * F)
    rM += 0 * (E ** Math.abs(1)) * Math.cos(1 * D + 1 * M + 1 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(0)) * Math.cos(3 * D + 0 * M + -2 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(0)) * Math.cos(4 * D + 0 * M + -3 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(-1)) * Math.cos(2 * D + -1 * M + 2 * M_ + 0 * F)
    rM += 1165 * (E ** Math.abs(2)) * Math.cos(0 * D + 2 * M + 1 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(1)) * Math.cos(1 * D + 1 * M + -1 * M_ + 0 * F)
    rM += 0 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + 3 * M_ + 0 * F)
rM += 8752 * (E ** Math.abs(0)) * Math.cos(2 * D + 0 * M + -1 * M_ + -2 * F);
rM = 385000.56 + rM / 1000;
let result;
switch (OptResult.toUpperCase().replace(/ /g, "")) {
case "AU":
result = rM / 149597870.7;
break;
case "KM":
result = rM;
break;
case "ER":
result = rM / 6371;
break;
default:
result = rM;
}
// Result of Calculation
return result;
}
//

function MoonApparentRightAscension(jd) {
  // Declare variables and their data types
  let lambda;
  let beta;
  let epsilon;
  let alpha;

  // Perform calculations
  lambda = MoonGeocentricLongitude(jd, "Apparent");
  beta = MoonGeocentricLatitude(jd, "Apparent");
  epsilon = ObliquityOfEcliptic(jd);
  alpha = radToDeg(Math.atan2(Math.sin(degToRad(lambda)) * Math.cos(degToRad(epsilon)) - Math.tan(degToRad(beta)) * Math.sin(degToRad(epsilon)), Math.cos(degToRad(lambda))));
  alpha = ModFDiv(alpha , 360) ;

  // Return result
  return alpha;
}
//
function MoonApparentDeclination(JD) {
let Lambda, Beta, Epsilon, Delta;
Lambda = degToRad(MoonGeocentricLongitude(JD, "Apparent"));
Beta = degToRad(MoonGeocentricLatitude(JD, "Apparent"));
Epsilon = degToRad(ObliquityOfEcliptic(JD));
Delta = (Math.asin(Math.sin(Beta) * Math.cos(Epsilon) + Math.cos(Beta) * Math.sin(Epsilon) * Math.sin(Lambda))) * 180 / Math.PI;
return Delta;
}
//
function MoonEquatorialHorizontalParallax(JD) {
  // Deklarasi Variabel dan Tipe Variabel
  let R;
  let Pi;

  // Proses Perhitungan
  R = MoonGeocentricDistance(JD, "KM");
  Pi = Math.asin(6378.14 / R) * (180 / Math.PI);

  // Hasil Perhitungan
  return Pi;
}
//
function MoonAngularSemiDiameter(JD) {
  // Declare variables and their types
  let R = 0;
  let Pi = 0;
  let K = 0.271481;
  let s = 0;

  // Calculations
  R = MoonGeocentricDistance(JD, "KM");
  Pi = MoonEquatorialHorizontalParallax(JD);
  s = Math.asin(K * Math.sin(Pi * Math.PI / 180)) * 180 / Math.PI;
  s = (358473400 / R) / 3600;

  // Result
  return s;
}
//
function MoonSunGeocentricElongation(JD) {
  // Variables declaration and type
  let DeltaSun;
  let AlphaSun;
  let DeltaMoon;
  let AlphaMoon;
  let Psi;

  // Calculation process
  DeltaSun = SunApparentDeclination(JD);
  AlphaSun = SunApparentRightAscension(JD);
  DeltaMoon = MoonApparentDeclination(JD);
  AlphaMoon = MoonApparentRightAscension(JD);
  Psi = Math.acos(Math.sin(DeltaSun * Math.PI/180) * Math.sin(DeltaMoon * Math.PI/180) + Math.cos(DeltaSun * Math.PI/180) * Math.cos(DeltaMoon * Math.PI/180) * Math.cos((AlphaSun - AlphaMoon) * Math.PI/180)) * 180/Math.PI;

  // Result of calculation
  return Psi;
}
//
function MoonDiskIlluminatedFraction(JD) {
  // Deklarasi Variabel dan Tipe Variabel
  let RSun;
  let RMoon;
  let Psi;
  let i;
  let K;

  // Proses Perhitungan
  RSun = SunGeocentricDistance(JD, "KM");
  RMoon = MoonGeocentricDistance(JD, "KM");
  Psi = MoonSunGeocentricElongation(JD);
  i = Math.atan2(RSun * Math.sin(Psi * Math.PI / 180), RMoon - RSun * Math.cos(Psi * Math.PI / 180)) * 180 / Math.PI;
  K = (1 + Math.cos(i * Math.PI / 180)) / 2;

  // Hasil Perhitungan
  return K;
}
//
function MoonBrightLimbAngle(JD) {
  let DeltaSun = SunApparentDeclination(JD);
  let AlphaSun = SunApparentRightAscension(JD);
  let DeltaMoon = MoonApparentDeclination(JD);
  let AlphaMoon = MoonApparentRightAscension(JD);
  let y_Num = Math.cos(DeltaSun * Math.PI / 180) * Math.sin((AlphaSun - AlphaMoon) * Math.PI / 180);
  let x_Num = Math.sin(DeltaSun * Math.PI / 180) * Math.cos(DeltaMoon * Math.PI / 180) - Math.cos(DeltaSun * Math.PI / 180) * Math.sin(DeltaMoon * Math.PI / 180) * Math.cos((AlphaSun - AlphaMoon) * Math.PI / 180);
  let Chi = Math.atan2(y_Num, x_Num) * 180 / Math.PI;
  Chi = ModFDiv(Chi , 360);

  return Chi;
}






     function MoonPhases(K, Phase) {
  // From a code by Michael Friedrich
  // found at http://members.aon.at/excelapps/excelapps.htm#kalender
  
  let T, JDE, E, M, MS, F, Omega;
  let A1, A2, A3, A4, A5, A6, A7, A8, A9, A10, A11, A12, A13, A14;
  let PT, W, PK;
  let y;

  //Y = Year(ThisDate) + CDbl(ThisDate - DateSerial(Year(ThisDate), 1, 1)) / 365.25
  //k = Int((Y - 2000) * 12.3685)
 
  K = K + Phase * 0.25;

  T = K / 1236.85;
  JDE = 2451550.09765 + 29.530588853 * K + 0.0001337 * Math.pow(T, 2) - 0.00000015 * Math.pow(T, 3) + 0.00000000073 * Math.pow(T, 4);
  E = 1 - 0.002516 * T - 0.0000074 * Math.pow(T, 2);
  M = 2.5534 + 29.10535669 * K - 0.0000218 * Math.pow(T, 2) - 0.00000011 * Math.pow(T, 3);
  MS = 201.5643 + 385.81693528 * K + 0.0107438 * Math.pow(T, 2) + 0.00001239 * Math.pow(T, 3) - 0.000000058 * Math.pow(T, 4);
  F = 160.7108 + 390.67050274 * K - 0.0016341 * Math.pow(T, 2) - 0.00000227 * Math.pow(T, 3) + 0.000000011 * Math.pow(T, 4);
  Omega = 124.7746 - 1.5637558 * K + 0.0020691 * Math.pow(T, 2) + 0.00000215 * Math.pow(T, 3);
  
  M = degToRad(ModFDiv(M, 360));
  MS = degToRad(ModFDiv(MS, 360));
  F = degToRad(ModFDiv(F, 360));
  Omega = degToRad(ModFDiv(Omega, 360));

  //Argumente der Planeten

  A1 = degToRad(ModFDiv(299.77 + 0.107408 * K - 0.009173 * Math.pow(T, 2), 360));
  A2 = degToRad(ModFDiv(251.88 + 0.016321 * K, 360));
  A3 = degToRad(ModFDiv(251.83 + 26.651886 * K, 360));
  A4 = degToRad(ModFDiv(349.42 + 36.412478 * K, 360));
  A5 = degToRad(ModFDiv(84.66 + 18.206239 * K, 360));
  A6 = degToRad(ModFDiv(141.74 + 53.303771 * K, 360));
  A7 = degToRad(ModFDiv(207.14 + 2.453732 * K, 360));
  A8 = degToRad(ModFDiv(154.84 + 7.30686 * K, 360));
  A9 = degToRad(ModFDiv(34.52 + 27.261239 * K, 360));
  A10 = degToRad(ModFDiv(207.19 + 0.121824 * K, 360));
  A11 = degToRad(ModFDiv(291.34 + 1.844379 * K, 360));
  A12 = degToRad(ModFDiv(161.72 + 24.198154 * K, 360));
  A13 = degToRad(ModFDiv(239.56 + 25.513099 * K, 360));
  A14 = degToRad(ModFDiv(331.55 + 3.592518 * K, 360));


if (Phase === 0) {
PT = -0.4072 * Math.sin(MS) + 0.17241 * E * Math.sin(M) + 0.01608 * Math.sin(2 * MS)
+ 0.01039 * Math.sin(2 * F) + 0.00739 * E * Math.sin(MS - M) - 0.00514 * E * Math.sin(MS + M)
+ 0.00208 * Math.pow(E, 2) * Math.sin(2 * M) - 0.00111 * Math.sin(MS - 2 * F) - 0.00057 * Math.sin(MS + 2 * F)
+ 0.00056 * E * Math.sin(2 * MS + M) - 0.00042 * Math.sin(3 * MS) + 0.00042 * E * Math.sin(M + 2 * F)
+ 0.00038 * E * Math.sin(M - 2 * F) - 0.00024 * E * Math.sin(2 * MS - M)
- 0.00017 * Math.sin(Omega) - 0.00007 * Math.sin(MS + 2 * M) + 0.00004 * Math.sin(2 * MS - 2 * F)
+ 0.00004 * Math.sin(3 * M) + 0.00003 * Math.sin(MS + M - 2 * F) + 0.00003 * Math.sin(2 * MS + 2 * F)
- 0.00003 * Math.sin(MS + M + 2 * F) + 0.00003 * Math.sin(MS - M + 2 * F) - 0.00002 * Math.sin(MS - M - 2 * F)
- 0.00002 * Math.sin(3 * MS + M) + 0.00002 * Math.sin(4 * MS);
W = 0;
}



if (Phase === 2) {
  PT = -0.40614 * Math.sin(MS) + 0.17302 * E * Math.sin(M) + 0.01614 * Math.sin(2 * MS) +
    0.01043 * Math.sin(2 * F) + 0.00734 * E * Math.sin(MS - M) - 0.00515 * E * Math.sin(MS + M) +
    0.00209 * E ** 2 * Math.sin(2 * M) - 0.00111 * Math.sin(MS - 2 * F) - 0.00057 * Math.sin(MS + 2 * F) +
    0.00056 * E * Math.sin(2 * MS + M) - 0.00042 * Math.sin(3 * MS) + 0.00042 * E * Math.sin(M + 2 * F) +
    0.00038 * E * Math.sin(M - 2 * F) - 0.00024 * E * Math.sin(2 * MS - M) -
    0.00017 * Math.sin(Omega) - 0.00007 * Math.sin(MS + 2 * M) + 0.00004 * Math.sin(2 * MS - 2 * F) +
    0.00004 * Math.sin(3 * M) + 0.00003 * Math.sin(MS + M - 2 * F) + 0.00003 * Math.sin(2 * MS + 2 * F) -
    0.00003 * Math.sin(MS + M + 2 * F) + 0.00003 * Math.sin(MS - M + 2 * F) - 0.00002 * Math.sin(MS - M - 2 * F) -
    0.00002 * Math.sin(3 * MS + M) + 0.00002 * Math.sin(4 * MS);
    W = 0;
}



// Periodic terms for first and last phases
if (Phase === 1 || Phase === 3) {
  PT = -0.62801 * Math.sin(MS) + 0.17172 * E * Math.sin(M) - 0.01183 * E * Math.sin(MS + M)
    + 0.00862 * Math.sin(2 * MS) + 0.00804 * Math.sin(2 * F) + 0.00454 * E * Math.sin(MS - M)
    + 0.00204 * Math.pow(E, 2) * Math.sin(2 * M) - 0.0018 * Math.sin(MS - 2 * F) - 0.0007 * Math.sin(MS + 2 * F)
    - 0.0004 * Math.sin(3 * MS) - 0.00034 * E * Math.sin(2 * MS - M) + 0.00032 * E * Math.sin(M + 2 * F)
    + 0.00032 * E * Math.sin(M - 2 * F) - 0.00028 * Math.pow(E, 2) * Math.sin(MS + 2 * M) + 0.00027 * E * Math.sin(2 * MS + M)
    - 0.00017 * Math.sin(Omega) - 0.00005 * Math.sin(MS - M - 2 * F) + 0.00004 * Math.sin(2 * MS + 2 * F)
    - 0.00004 * Math.sin(MS + M + 2 * F) + 0.00004 * Math.sin(MS - 2 * M) + 0.00003 * Math.sin(MS + M - 2 * F)
    + 0.00003 * Math.sin(3 * M) + 0.00002 * Math.sin(2 * MS - 2 * F) + 0.00002 * Math.sin(MS - M + 2 * F)
    - 0.00002 * Math.sin(3 * MS + M);
  W = 0.00306 - 0.00038 * E * Math.cos(M) + 0.00026 * Math.cos(MS)
    - 0.00002 * Math.cos(MS - M) + 0.00002 * Math.cos(MS + M) + 0.00002 * Math.cos(2 * F);
  if (Phase === 3) {
    W = -W;
  }
}

PK = 0.000325 * Math.sin(A1) + 0.000165 * Math.sin(A2) + 0.000164 * Math.sin(A3)
  + 0.000126 * Math.sin(A4) + 0.00011 * Math.sin(A5) + 0.000062 * Math.sin(A6)
  + 0.00006 * Math.sin(A7) + 0.000056 * Math.sin(A8) + 0.000047 * Math.sin(A9)
  + 0.000042 * Math.sin(A10) + 0.00004 * Math.sin(A11) + 0.000037 * Math.sin(A12)
  + 0.000035 * Math.sin(A13) + 0.000023 * Math.sin(A14);
  
return JDE + PK + PT + W;

}

//untuk ijtimak

function SameLongitudeTracking(JDE) {
  let moonLong;
  let sunLong;
  let Intervals = new Array(9);
  let JDEProsess;
  let selisih;
  let i;
  let J;
  let K;
  let l = 0;
  
  Intervals[0] = 1 / 24;
  Intervals[1] = 1 / 24 / 60;
  Intervals[2] = 1 / 24 / 60 / 60;
  Intervals[3] = 1 / 24 / 60 / 60 / 10;
  Intervals[4] = 1 / 24 / 60 / 60 / 100;
  Intervals[5] = 1 / 24 / 60 / 60 / 1000;
  Intervals[6] = 1 / 24 / 60 / 60 / 10000;
  Intervals[7] = 1 / 24 / 60 / 60 / 100000;
  Intervals[8] = 1 / 24 / 60 / 60 / 1000000;

  moonLong = MoonGeocentricLongitude(JDE);
  sunLong = SunGeocentricLongitude(JDE);
  while (l < 9) {
    while (moonLong < sunLong) {
      JDE = JDE + Intervals[l];
      moonLong = MoonGeocentricLongitude(JDE);
      sunLong = SunGeocentricLongitude(JDE);
    }
    
    JDE = JDE - 2 * Intervals[l];
    l = l + 1;
   
    JDE = JDE + Intervals[l];
    moonLong = MoonGeocentricLongitude(JDE);
    sunLong = SunGeocentricLongitude(JDE);

    selisih = Math.abs(moonLong - sunLong);
   
    if (selisih <= 0.0000001) {
      break;
    }
  }
  return JDE;
}

function BulanTahunHijri_K(BulanHijri, TahunHijri) {

  var Lunasi_N = (TahunHijri + 29.530589 * (BulanHijri - 1) / 354.367068 - 1410) * 12 - 128; 
  return Lunasi_N;
}


function LunasiKeN(BulanHijri, TahunHijri) {
  var bulanKeN = (BulanHijri - 1) + (TahunHijri - 1) * 12 + 1; // Menghitung bulan ke-n dari tahun pertama dalam kalender Hijriyah
  var lunasiKeN = 1948439.5 + (bulanKeN - 1) * 29.530588853; // Menghitung lunasi ke-n dari bulan ke-n
  var lunasi1410 = 1948439.5; // Lunasi tanggal 1 Muharram 1410 H
  var jumlahLunasi = Math.floor(lunasiKeN - lunasi1410 + 0.5); // Menghitung selisih lunasi antara bulan dan tahun yang diberikan dengan tanggal 1 Muharram 1410 H dan membulatkan ke bawah
  return jumlahLunasi; // Mengembalikan nilai jumlah lunasi
}



   
// JDE Ghurub syamsi
function JDEGhurubusSyamsi(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt) {
  let Tahun;
  let Bulan;
  let tanggal;
  let JD;
  let PW;
  let Delt;
  let DM;
  let PM;
  let SDM;
  let Ref;
  let Dip;
  let HM;
  let TGhurub;
  let JamGhurub;
  let ZN;
  let Kor1;
  let Kor2;
  let i;
  
  Delt = Deltat(JDE);
  ZN = LocalGeoLong / 15;
  JD = JDE + ZN / 24 - Delt / 86400;
  tanggal = JDKM(JD, 0, "tglm");
  Bulan = JDKM(JD, 0, "blnm");
  Tahun = JDKM(JD, 0, "thnm");
  JD = KMJD(tanggal, Bulan, Tahun);
  
  for (i = 0; i <= 7; i++) {
    Delt = Deltat(JD);
    JDE = JD + Delt / 86400;
    PW = EquationOfTime(JD);
    DM = SunApparentDeclination(JDE);
    SDM = SunAngularSemiDiameter(JDE);
    PM = SunEquatorialHorizontalParallax(JDE);
    Ref = 0 + 34 / 60 + 30 / 3600;
    Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60;
    HM = 0 - SDM - Ref - Dip + PM;
    TGhurub = radToDeg(Math.acos(-Math.tan(degToRad(LocalGeoLat)) * Math.tan(degToRad(DM)) + Math.sin(degToRad(HM)) / Math.cos(degToRad(LocalGeoLat)) / Math.cos(degToRad(DM))));
    JamGhurub = TGhurub / 15;
    Kor1 = 12 + JamGhurub - PW;
    JD = KMJD(tanggal, Bulan, Tahun, Kor1, ZN);
  }
  
  Delt = Deltat(JD);
  return JD + Delt / 86400;
}

// JDE thuluk
function JDEThulu_uusSyamsi(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt) {
let Tahun;
let Bulan;
let tanggal;
let JD;
let PW;
let Delt;
let DM;
let SDM;
let PM;
let Ref;
let Dip;
let HM;
let TThulu_u;
let JamThulu_u;
let ZN;
let Kor1;
let Kor2;
let i;

Delt = Deltat(JDE);
ZN = LocalGeoLong / 15;
JD = JDE + ZN / 24 - Delt / 86400;
tanggal = JDKM(JD, 0, "tglm");
Bulan = JDKM(JD, 0, "blnm");
Tahun = JDKM(JD, 0, "thnm");

JD = KMJD(tanggal, Bulan, Tahun);

for (i = 0; i <= 7; i++) {
Delt = Deltat(JD);
JDE = JD + Delt / 86400;
PW = EquationOfTime(JD);
DM = SunApparentDeclination(JDE);
PM = SunEquatorialHorizontalParallax(JDE);
SDM = SunAngularSemiDiameter(JDE);
Ref = 0 + 34 / 60 + 30 / 3600;
Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60;
HM = 0 - SDM - Ref - Dip + PM;
TThulu_u = radToDeg(Acs(-Math.tan(degToRad(LocalGeoLat)) * Math.tan(degToRad(DM)) + Math.sin(degToRad(HM)) / Math.cos(degToRad(LocalGeoLat)) / Math.cos(degToRad(DM))));
JamThulu_u = TThulu_u / 15;
Kor1 = 12 - JamThulu_u - PW;
JD = KMJD(tanggal, Bulan, Tahun, Kor1, ZN);
}
Delt = Deltat(JD);
return JD + Delt / 86400;
}


// ghurub qomar
function JDEGhurubulQomar(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt) {

    let TggBulan, Altbulan, SDB, PB, Ref, Dip;
    let Intervals = new Array(8);
    let l = 0;

    Intervals[0] = 1 / 24;
    Intervals[1] = 1 / 24 / 60;
    Intervals[2] = 1 / 24 / 60 / 60;
    Intervals[3] = 1 / 24 / 60 / 60 / 10;
    Intervals[4] = 1 / 24 / 60 / 60 / 100;
    Intervals[5] = 1 / 24 / 60 / 60 / 1000;
    Intervals[6] = 1 / 24 / 60 / 60 / 10000;
    Intervals[7] = 1 / 24 / 60 / 60 / 100000;

    SDB = MoonAngularSemiDiameter(JDE);
    PB = MoonEquatorialHorizontalParallax(JDE);
    Ref = 0 + 34 / 60 + 30 / 3600;
    Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60;
    TggBulan = -(34 / 60) + 0.7275 * PB - 0.0353 * Math.sqrt(LocalGeoAlt);

    Altbulan = tinggibulan(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt, "ATAS");
    if (Altbulan > TggBulan) {
          while (l < 7) {
                  if (Altbulan > TggBulan) {
                    JDE = JDE + Intervals[l];
                    SDB = MoonAngularSemiDiameter(JDE);
                    PB = MoonEquatorialHorizontalParallax(JDE);
                    Ref = 0 + 34 / 60 + 30 / 3600;
                    Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60;
                    TggBulan = -(34 / 60) + 0.7275 * PB - 0.0353 * Math.sqrt(LocalGeoAlt);

                    Altbulan = tinggibulan(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt, "ATAS");
                  
                  } else {
                  
                  JDE = JDE - 2 * Intervals[l];
                  l = l + 1;
                
                    JDE = JDE + Intervals[l];
                    SDB = MoonAngularSemiDiameter(JDE);
                    PB = MoonEquatorialHorizontalParallax(JDE);
                    Ref = 0 + 34 / 60 + 30 / 3600;
                    Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60;
                    TggBulan = -(34 / 60) + 0.7275 * PB - 0.0353 * Math.sqrt(LocalGeoAlt);

                    Altbulan = tinggibulan(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt, "ATAS");
                    }
                    selisih = Math.abs(Altbulan - TggBulan);
                  
                    if (selisih <= 0.0000001) {
                      break;
                    }
          }
    } else {
          while (l < 7) {
                if (Altbulan < TggBulan) {
                  JDE = JDE - Intervals[l];
                  SDB = MoonAngularSemiDiameter(JDE);
                  PB = MoonEquatorialHorizontalParallax(JDE);
                  Ref = 0 + 34 / 60 + 30 / 3600;
                  Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60;
                  TggBulan = -(34 / 60) + 0.7275 * PB - 0.0353 * Math.sqrt(LocalGeoAlt);

                  Altbulan = tinggibulan(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt, "ATAS");
                
                } else {
                
                JDE = JDE + 2 * Intervals[l];
                l = l + 1;
              
                  JDE = JDE + Intervals[l];
                  SDB = MoonAngularSemiDiameter(JDE);
                  PB = MoonEquatorialHorizontalParallax(JDE);
                  Ref = 0 + 34 / 60 + 30 / 3600;
                  Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60;
                  TggBulan = -(34 / 60) + 0.7275 * PB - 0.0353 * Math.sqrt(LocalGeoAlt);

                  Altbulan = tinggibulan(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt, "ATAS");
                  }
                selisih = Math.abs(Altbulan - TggBulan);
      
              if (selisih <= 0.0000001) {
                break;
              }
          }
    }

  return JDE;
}


// thuluk qomar

function JDEThulu_ulQomar(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt) {

  let tanggal, Bulan, Tahun, Delt, JDTanggal, JDAcuan, JDEAcuan, Zone;
  let JDEPokok, JDEH = [];

  Zone = Math.floor(LocalGeoLong / 15);
  Delt = Deltat(JDE);
  JDTanggal = JDE - Delt / 86400;
  tanggal = JDKM(JDTanggal, Zone, "TGLM");
  Bulan = JDKM(JDTanggal, Zone, "BLNM");
  Tahun = JDKM(JDTanggal, Zone, "THNM");
  JDAcuan = KMJD(tanggal, Bulan, Tahun, 0, Zone);
  Delt = Deltat(JDAcuan);
  JDEAcuan = JDAcuan + Delt / 86400;

  let JDEThulu_ulQomar = -1;

  for (let i = 0; i <= 2; i++) {
    JDEH[i] = JDEThulu_ulQomarPross(JDEAcuan + (i - 1), LocalGeoLat, LocalGeoLong, LocalGeoAlt);
    if (JDEH[i] >= JDEAcuan && JDEH[i] < (JDEAcuan + 1)) {
      JDEThulu_ulQomar = JDEH[i];
      break;
    }
    JDEPokok = JDE;
  }

  return JDEThulu_ulQomar;
}



  //waktu awal sholat
//Sholat Dhuhur
function dhuhur(JDE,geolong,tz) {
  let pw = EquationOfTime(JDE);
  let dh = 12 - pw + ((15 * tz) - geolong) / 15;
  let iht = 1 / 30;
  return dh + iht;
}
//Sholat Ashar
function ashar(JDE, geolat, geolong, tz) {
let pw = EquationOfTime(JDE);
let kwd = ((15 * tz) - geolong) / 15;
let iht = 1 / 30;
let sundec = SunApparentDeclination(JDE);
let ist = Math.abs(sundec - geolat);
let hashr = radToDeg( Math.atan (1 / ( Math.tan(degToRad(ist)) + 1 )));
let swashr = radToDeg( Math.acos( Math.sin(degToRad(hashr)) / Math.cos(degToRad(sundec)) / Math.cos(degToRad(geolat)) - Math.tan(degToRad(sundec)) * Math.tan(degToRad(geolat))));
let ashr1 = swashr / 15
let ashr2 = 12 - pw + ashr1 + kwd + iht;
return ashr2;

}
// Sholat Maghrib
function maghrib(JDE, geolat, geolong, geoalt, tz) {
let pw = EquationOfTime(JDE);
let kwd = ((15 * tz) - geolong) / 15;
let iht = 1 / 30;
let sundec = SunApparentDeclination(JDE);
let a = 1.76 * Math.sqrt(geoalt) / 60;
let sdm = SunAngularSemiDiameter(JDE);
let ref = 34 / 60;
let hm = -(a + sdm + ref);
let swamagh = radToDeg( Math.acos( Math.sin(degToRad(hm)) / Math.cos(degToRad(sundec)) / Math.cos(degToRad(geolat)) - Math.tan(degToRad(sundec)) * Math.tan(degToRad(geolat))));
let mgb1 = swamagh / 15;
let mgb2 = 12 - pw + mgb1 + kwd + iht;
return mgb2;

}

// Sholat isya
function isya(JDE, geolat, geolong, tz) {
let pw = EquationOfTime(JDE);
let kwd = ((15 * tz) - geolong) / 15;
let iht = 1 / 30;
let sundec = SunApparentDeclination(JDE);
let hisy = -18;
let swisy = radToDeg( Math.acos( Math.sin(degToRad(hisy)) / Math.cos(degToRad(sundec)) / Math.cos(degToRad(geolat)) - Math.tan(degToRad(sundec)) * Math.tan(degToRad(geolat))));
let isy1 = swisy / 15;
let isy2 = 12 - pw + isy1 + kwd + iht;
return isy2;
}

// Sholat shubuh
function shubuh(JDE, geolat, geolong, tz) {
let pw = EquationOfTime(JDE);
let kwd = ((15 * tz) - geolong) / 15;
let iht = 1 / 30;
let sundec = SunApparentDeclination(JDE);
let hsbh = -20;
let swsbh = radToDeg( Math.acos( Math.sin(degToRad(hsbh)) / Math.cos(degToRad(sundec)) / Math.cos(degToRad(geolat)) - Math.tan(degToRad(sundec)) * Math.tan(degToRad(geolat))));
let sbh1 = swsbh / 15;
let sbh2 = 12 - pw - sbh1 + kwd + iht;
return sbh2;
}

// waktu terbit
function terbit(JDE, geolat, geolong, geoalt, tz) {
let pw = EquationOfTime(JDE);
let kwd = ((15 * tz) - geolong) / 15;
let iht = 1 / 30;
let sundec = SunApparentDeclination(JDE);
let a = 1.76 * Math.sqrt(geoalt) / 60;
let sdm = SunAngularSemiDiameter(JDE);
let ref = 34 / 60;
let hm = -(a + sdm + ref);
let swamagh = radToDeg( Math.acos( Math.sin(degToRad(hm)) / Math.cos(degToRad(sundec)) / Math.cos(degToRad(geolat)) - Math.tan(degToRad(sundec)) * Math.tan(degToRad(geolat))));
let trbt1 = swamagh / 15;
let trbt2 = 12 - pw - trbt1 + kwd - iht;
return trbt2;
}

// Sholat dluha
function dluha(JDE, geolat, geolong, tz) {
let pw = EquationOfTime(JDE);
let kwd = ((15 * tz) - geolong) / 15;
let iht = 1 / 30;
let sundec = SunApparentDeclination(JDE);
let hdha = 4.5;
let swdha = radToDeg( Math.acos( Math.sin(degToRad(hdha)) / Math.cos(degToRad(sundec)) / Math.cos(degToRad(geolat)) - Math.tan(degToRad(sundec)) * Math.tan(degToRad(geolat))));
let dha1 = swdha / 15;
let dha2 = 12 - pw - dha1 + kwd + iht;
return dha2;
}
//
//
function tinggibulan(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt, Hasil="HAQIQI") {
var Delt, JD, PW, UT, SunGeolong, SunGeoLat, SudutWaktuMatahari, MoonGeoLong, MoonGeoLat, SudutWaktuBulan, PB, SDB, refA, Ref, Dip, AsensiorektaMatahari, AsensiorektaBulan, SelisihAsensiorekta, tinggibulanHaqiqi, tinggibulan;

Delt = Deltat(JDE);
JD = JDE - Delt / 86400;
PW = EquationOfTime(JD);
UT = JDKM(JD, 0, "jamdes");
SunGeolong = 180 - 15 * (UT + PW);
SunGeoLat = SunApparentDeclination(JDE);
MoonGeoLat = MoonApparentDeclination(JDE);
SudutWaktuMatahari = LocalGeoLong - SunGeolong;
AsensiorektaBulan = MoonApparentRightAscension(JDE);
AsensiorektaMatahari = SunApparentRightAscension(JDE);
SelisihAsensiorekta = AsensiorektaBulan - AsensiorektaMatahari;
SudutWaktuBulan = SudutWaktuMatahari + AsensiorektaMatahari - AsensiorektaBulan;
Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60;
PB = MoonEquatorialHorizontalParallax(JDE);
SDB = MoonAngularSemiDiameter(JDE);
tinggibulanHaqiqi = radToDeg(Math.asin(Math.sin(degToRad(LocalGeoLat)) * Math.sin(degToRad(MoonGeoLat)) + Math.cos(degToRad(LocalGeoLat)) * Math.cos(degToRad(MoonGeoLat)) * Math.cos(degToRad(SudutWaktuBulan))));
tinggibulan = tinggibulanHaqiqi - (PB * Math.cos(degToRad(tinggibulanHaqiqi)));

switch (Hasil.replace(/\s/g, "").toUpperCase()) {
case "ATAS":
tinggibulan += SDB;
break;
case "BAWAH":
tinggibulan -= SDB;
break;
case "HAQIQI":
return tinggibulanHaqiqi;
case "TOPOCENTRIS":
break;
default:
// tetap titik pusat
break;
}

if (tinggibulan > Dip) tinggibulan += Dip;
refA = tinggibulan + (7.31 / (tinggibulan + 4.4));
Ref = 0.0167 / Math.tan(degToRad(refA));
if (tinggibulan > 0.575774813512485) tinggibulan += Ref;
if (tinggibulan > 90) tinggibulan = 180 - tinggibulan;
if (tinggibulan < -90) tinggibulan = -(180 - tinggibulan);

return tinggibulan;
}

// tinggi mth
function tinggimatahari(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt, Hasil) {
let Delt, JD, PW, UT, SunGeolong, SunGeoLat, SudutWaktuMatahari, PM, SDM, refA, Ref, Dip;
Delt = Deltat(JDE); 
JD = JDE - Delt / 86400; 
PW = EquationOfTime(JD); 
UT = JDKM(JD, 0, "jamdes"); 
SunGeolong = 180 - 15 * (UT + PW); 
SunGeoLat = SunApparentDeclination(JDE); SudutWaktuMatahari = LocalGeoLong - SunGeolong;
Dip = 1.76 * Math.sqrt(LocalGeoAlt) / 60; 
PM = SunEquatorialHorizontalParallax(JDE); 
SDM = SunAngularSemiDiameter(JDE); 
let tinggimatahari = radToDeg(Math.asin(Math.sin(degToRad(LocalGeoLat)) * Math.sin(degToRad(SunGeoLat)) + Math.cos(degToRad(LocalGeoLat)) * Math.cos(degToRad(SunGeoLat)) * Math.cos(degToRad(SudutWaktuMatahari)))); 
tinggimatahari = tinggimatahari - PM;
switch (Hasil.trim().toUpperCase()) { 
  case "ATAS": 
  tinggimatahari = tinggimatahari + SDM; 
  break; 
  case "BAWAH": 
  tinggimatahari = tinggimatahari - SDM;
  break; 
  default: // tetap titik pusat break; 
  }
if (tinggimatahari > Dip) { 
  tinggimatahari = tinggimatahari + Dip; 
  } 
  refA = tinggimatahari + (7.31 / (tinggimatahari + 4.4)); 
  Ref = 0.0167 / Math.tan(degToRad(refA)); 
  if (tinggimatahari > 0.575774813512485) { 
    tinggimatahari = tinggimatahari + Ref; 
    } 
    if (tinggimatahari > 90) { 
      tinggimatahari = 180 - tinggimatahari; 
      } 
      if (tinggimatahari < -90) { 
        tinggimatahari = -(180 - tinggimatahari); 
        }
return tinggimatahari;
}

//
function AzimuthBulan(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt) {
let Delt, JD, PW, UT, SunGeolong, MoonGeoLong, MoonGeoLat, AsensiorektaMatahari, AsensiorektaBulan, SelisihAsensiorekta;

AsensiorektaBulan = MoonApparentRightAscension(JDE);
AsensiorektaMatahari = SunApparentRightAscension(JDE);
SelisihAsensiorekta = AsensiorektaBulan - AsensiorektaMatahari;

Delt = Deltat(JDE);
JD = JDE - Delt / 86400;
PW = EquationOfTime(JD);
UT = JDKM(JD, 0, "jamdes");
SunGeolong = 180 - 15 * (UT + PW);
MoonGeoLong = ModFDiv(SunGeolong + SelisihAsensiorekta,360);
MoonGeoLat = MoonApparentDeclination(JDE);

return azimuthWithCosine(MoonGeoLat, MoonGeoLong, LocalGeoLat, LocalGeoLong);
}

//
function AzimuthMatahari(JDE, LocalGeoLat, LocalGeoLong, LocalGeoAlt) {
let Delt;
let JD;
let PW;
let UT;
let SunGeolong;
let SunGeoLat;

Delt = Deltat(JDE);
JD = JDE - Delt / 86400;
PW = EquationOfTime(JD);
UT = JDKM(JD, 0, "jamdes");
SunGeolong = 180 - 15 * (UT + PW);
SunGeoLat = SunApparentDeclination(JDE);

return azimuthWithCosine(SunGeoLat, SunGeolong, LocalGeoLat, LocalGeoLong);
}




      </script>
   </body>
</html>
</div>
<div class='post-footer'>
<div class='post-footer-line post-footer-line-1'>
</div>
</div>
</div>
</div>
<section class='comments' data-num-comments='0' id='comments'>
<a name='comments'></a>
</section>
</article>
</div>
<div class='post-feeds'>
</div>
</div></div>

<script type="text/javascript" src="https://www.blogger.com/static/v1/widgets/116388341-widgets.js"></script>
<script type='text/javascript'>
window['__wavt'] = 'AOuZoY4gwfXrU4NVxDnbO3FJpSdjhaXrVA:1717206922490';_WidgetManager._Init('//www.blogger.com/rearrange?blogID\x3d2539000132118182573','//falakiyah-info.blogspot.com/2024/03/hisabawalbulan.html?m\x3d1','2539000132118182573');
_WidgetManager._SetDataContext([{'name': 'blog', 'data': {'blogId': '2539000132118182573', 'title': 'FALAKIYAH INFO', 'url': 'https://falakiyah-info.blogspot.com/2024/03/hisabawalbulan.html?m\x3d1', 'canonicalUrl': 'https://falakiyah-info.blogspot.com/2024/03/hisabawalbulan.html', 'homepageUrl': 'https://falakiyah-info.blogspot.com/?m\x3d1', 'searchUrl': 'https://falakiyah-info.blogspot.com/search', 'canonicalHomepageUrl': 'https://falakiyah-info.blogspot.com/', 'blogspotFaviconUrl': 'https://falakiyah-info.blogspot.com/favicon.ico', 'bloggerUrl': 'https://www.blogger.com', 'hasCustomDomain': false, 'httpsEnabled': true, 'enabledCommentProfileImages': true, 'gPlusViewType': 'FILTERED_POSTMOD', 'adultContent': false, 'analyticsAccountNumber': '', 'encoding': 'UTF-8', 'locale': 'en', 'localeUnderscoreDelimited': 'en', 'languageDirection': 'ltr', 'isPrivate': false, 'isMobile': true, 'isMobileRequest': true, 'mobileClass': ' mobile', 'isPrivateBlog': false, 'isDynamicViewsAvailable': true, 'feedLinks': '\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22FALAKIYAH INFO - Atom\x22 href\x3d\x22https://falakiyah-info.blogspot.com/feeds/posts/default\x22 /\x3e\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/rss+xml\x22 title\x3d\x22FALAKIYAH INFO - RSS\x22 href\x3d\x22https://falakiyah-info.blogspot.com/feeds/posts/default?alt\x3drss\x22 /\x3e\n\x3clink rel\x3d\x22service.post\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22FALAKIYAH INFO - Atom\x22 href\x3d\x22https://www.blogger.com/feeds/2539000132118182573/posts/default\x22 /\x3e\n\n\x3clink rel\x3d\x22alternate\x22 type\x3d\x22application/atom+xml\x22 title\x3d\x22FALAKIYAH INFO - Atom\x22 href\x3d\x22https://falakiyah-info.blogspot.com/feeds/6379423114701896843/comments/default\x22 /\x3e\n', 'meTag': '', 'adsenseHostId': 'ca-host-pub-1556223355139109', 'adsenseHasAds': false, 'adsenseAutoAds': false, 'boqCommentIframeForm': true, 'loginRedirectParam': '', 'view': '', 'dynamicViewsCommentsSrc': '//www.blogblog.com/dynamicviews/4224c15c4e7c9321/js/comments.js', 'dynamicViewsScriptSrc': '//www.blogblog.com/dynamicviews/def51946c7ab22b3', 'plusOneApiSrc': 'https://apis.google.com/js/platform.js', 'disableGComments': true, 'interstitialAccepted': false, 'sharing': {'platforms': [{'name': 'Get link', 'key': 'link', 'shareMessage': 'Get link', 'target': ''}, {'name': 'Facebook', 'key': 'facebook', 'shareMessage': 'Share to Facebook', 'target': 'facebook'}, {'name': 'BlogThis!', 'key': 'blogThis', 'shareMessage': 'BlogThis!', 'target': 'blog'}, {'name': 'Twitter', 'key': 'twitter', 'shareMessage': 'Share to Twitter', 'target': 'twitter'}, {'name': 'Pinterest', 'key': 'pinterest', 'shareMessage': 'Share to Pinterest', 'target': 'pinterest'}, {'name': 'Email', 'key': 'email', 'shareMessage': 'Email', 'target': 'email'}], 'disableGooglePlus': true, 'googlePlusShareButtonWidth': 0, 'googlePlusBootstrap': '\x3cscript type\x3d\x22text/javascript\x22\x3ewindow.___gcfg \x3d {\x27lang\x27: \x27en\x27};\x3c/script\x3e'}, 'hasCustomJumpLinkMessage': false, 'jumpLinkMessage': 'Read more', 'pageType': 'item', 'postId': '6379423114701896843', 'pageName': '', 'pageTitle': 'FALAKIYAH INFO'}}, {'name': 'features', 'data': {}}, {'name': 'messages', 'data': {'edit': 'Edit', 'linkCopiedToClipboard': 'Link copied to clipboard!', 'ok': 'Ok', 'postLink': 'Post Link'}}, {'name': 'template', 'data': {'name': 'custom', 'localizedName': 'Custom', 'isResponsive': true, 'isAlternateRendering': false, 'isCustom': true}}, {'name': 'view', 'data': {'classic': {'name': 'classic', 'url': '?view\x3dclassic'}, 'flipcard': {'name': 'flipcard', 'url': '?view\x3dflipcard'}, 'magazine': {'name': 'magazine', 'url': '?view\x3dmagazine'}, 'mosaic': {'name': 'mosaic', 'url': '?view\x3dmosaic'}, 'sidebar': {'name': 'sidebar', 'url': '?view\x3dsidebar'}, 'snapshot': {'name': 'snapshot', 'url': '?view\x3dsnapshot'}, 'timeslide': {'name': 'timeslide', 'url': '?view\x3dtimeslide'}, 'isMobile': false, 'title': 'FALAKIYAH INFO', 'description': '                                                \t                                                               HISAB AWAL BULAN            ...', 'url': 'https://falakiyah-info.blogspot.com/2024/03/hisabawalbulan.html?m\x3d1', 'type': 'item', 'isSingleItem': true, 'isMultipleItems': false, 'isError': false, 'isPage': false, 'isPost': true, 'isHomepage': false, 'isArchive': false, 'isLabelSearch': false, 'postId': 6379423114701896843}}, {'name': 'widgets', 'data': [{'title': 'Blog Posts', 'type': 'Blog', 'sectionId': 'main', 'id': 'Blog1', 'posts': [{'id': '6379423114701896843', 'title': '', 'showInlineAds': false}], 'footerBylines': [{'regionName': 'footer1', 'items': [{'name': 'icons', 'label': ''}]}], 'allBylineItems': [{'name': 'icons', 'label': ''}]}]}]);
_WidgetManager._RegisterWidget('_BlogView', new _WidgetInfo('Blog1', 'main', document.getElementById('Blog1'), {'cmtInteractionsEnabled': false, 'lightboxEnabled': true, 'lightboxModuleUrl': 'https://www.blogger.com/static/v1/jsbin/283473234-lbx.js', 'lightboxCssUrl': 'https://www.blogger.com/static/v1/v-css/13464135-lightbox_bundle.css'}, 'displayModeFull'));
</script>
</body>
</html>